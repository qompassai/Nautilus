/*
 * Wazuh Vulnerability scanner
 * Copyright (C) 2015, Wazuh Inc.
 * March 25, 2023.
 *
 * This program is free software; you can redistribute it
 * and/or modify it under the terms of the GNU General Public
 * License (version 2) as published by the FSF - Free Software
 * Foundation.
 */

#ifndef _DATABASE_FEED_MANAGER_HPP
#define _DATABASE_FEED_MANAGER_HPP

#include "../policyManager/policyManager.hpp"
#include "UNIXSocketRequest.hpp"
#include "cacheLRU.hpp"
#include "contentManager.hpp"
#include "contentRegister.hpp"
#include "databaseFeedManagerException.hpp"
#include "eventDecoder.hpp"
#include "feedIndexer.hpp"
#include "globalData.hpp"
#include "indexerConnector.hpp"
#include "jsonArrayParser.hpp"
#include "loggerHelper.h"
#include "observer.hpp"
#include "rocksDBWrapper.hpp"
#include "routerSubscriber.hpp"
#include "storeModel.hpp"
#include "vulnerabilityCandidate_generated.h"
#include "vulnerabilityDescription_generated.h"
#include "vulnerabilityRemediations_generated.h"
#include "vulnerabilityScanner.hpp"
#include <external/nlohmann/json.hpp>
#include <fstream>
#include <functional>
#include <memory>
#include <string>
#include <vector>

using namespace NSVulnerabilityScanner;
constexpr auto DATABASE_PATH {"queue/vd/feed"};
constexpr auto OFFSET_TRANSACTION_SIZE {1000};
constexpr auto EMPTY_KEY {""};

/**
 * @brief Scanning package data struct.
 */
struct PackageData final
{
    std::string name;    ///< Package name.
    std::string vendor;  ///< Package vendor.
    std::string format;  ///< Package format.
    std::string version; ///< Package version.
};

/**
 * @brief A struct for storing a pair of FlatBuffers data.
 *
 * The `FlatbufferDataPair` struct is designed to store a pair of related FlatBuffers data:
 * a `rocksdb::PinnableSlice` containing the serialized data and a pointer to the deserialized
 * data of type `FlatbufferType`. This allows for efficient storage and access to both the raw
 * serialized data and its parsed form.
 *
 * @tparam FlatbufferType The type of the FlatBuffers object that this struct represents.
 */
template<typename FlatbufferType>
struct FlatbufferDataPair final
{
    /**
     * @brief A slice to the serialized FlatBuffers data.
     *
     * The `slice` member stores a `rocksdb::PinnableSlice` that contains the serialized
     * FlatBuffers data.
     */
    rocksdb::PinnableSlice slice;

    /**
     * @brief A pointer to the deserialized FlatBuffers data.
     *
     * The `data` member is a pointer to the deserialized FlatBuffers data of type `FlatbufferType`.
     * It provides direct access to the parsed information.
     */
    const FlatbufferType* data = nullptr;
};

/**
 * @brief Represents a translation entry containing regular expressions for product and vendor identification,
 *        along with a vector of translated data.
 */
struct Translation final
{
    std::optional<std::regex> productRegex; ///< Regular expression for product identification.
    std::optional<std::regex> vendorRegex;  ///< Regular expression for vendor identification.
    std::optional<std::regex> versionRegex; ///< Regular expression for version identification.
    std::vector<PackageData> translation;   ///< Vector of translated data.
    std::vector<std::string> target;        ///< Vector of valid targets.
};

/**
 * @brief Translations cache.
 * @details Key: Translation ID, Value: Translation information.
 */
using TranslationLRUCache = LRUCache<std::string, Translation>;

/**
 * @brief DatabaseFeedManager class.
 *
 * @tparam TIndexerConnector Indexer connector type.
 * @tparam TPolicyManager Policy manager type.
 * @tparam TContentRegister Content register type.
 * @tparam TRouterSubscriber Router subscriber type.
 */
template<typename TIndexerConnector = IndexerConnector,
         typename TPolicyManager = PolicyManager,
         typename TContentRegister = ContentRegister,
         typename TRouterSubscriber = RouterSubscriber,
         typename TUNIXSocketRequest = UNIXSocketRequest,
         typename TRocksDBWrapper = Utils::RocksDBWrapper>
class TDatabaseFeedManager final : public Observer<nlohmann::json&>
{
public:
    /**
     * @brief Process and validated the message received by the router.
     *
     * @param message Message received by the router.
     * @param topicName Topic name.
     * @param orchestration Chain of actions to execute for each valid resource extracted from the message.
     */
    void processMessage(const std::vector<char>& message,
                        const std::string& topicName,
                        const std::function<void(const nlohmann::json&, Utils::IRocksDBWrapper*)>& orchestration)
    {
        auto parsedMessage = nlohmann::json::parse(message, nullptr, false);

        if (parsedMessage.is_discarded() || !parsedMessage.contains("paths") || !parsedMessage.contains("type") ||
            !parsedMessage.contains("offset"))
        {
            throw std::runtime_error("Invalid message");
        }
        // Lock the mutex to protect the access to the internal databases.
        std::scoped_lock<std::shared_mutex> lock(m_mutex);
        if (parsedMessage.at("type") == "offsets")
        {
            auto jsonPointer {"/data"_json_pointer};
            for (const auto& path : parsedMessage.at("paths"))
            {
                auto currentOffset = 0LL;
                logDebug2(WM_VULNSCAN_LOGTAG, "Processing file: %s", path.get_ref<const std::string&>().c_str());

                // Parse the file and execute the chain/orchestration for each valid resource.
                // The lambda function returns false if the module is stopped.
                // This uses the json sax api, so it is faster than the json tree api and it consumes less memory.
                // LCOV_EXCL_START
                JsonArray::parse(
                    path,
                    [&](nlohmann::json&& item, const size_t)
                    {
                        orchestration(item, m_feedDatabase.get());

                        // Extract the offset from the last element.
                        currentOffset = item.at("offset");

                        // Commit the transaction for every 200 elements.
                        return !m_shouldStop.load();
                    },
                    jsonPointer);
                // LCOV_EXCL_STOP

                // Update the offset in the database after processing the file.
                // If the module is stopped, we update the offset in the last processed element.
                // So that the next time the module is started, it will start from the last processed element.
                contentManagerUpdateOffset(topicName, currentOffset);

                if (m_shouldStop.load())
                {
                    throw DatabaseFeedManagerException("Module stopped.");
                }
            }
        }
        else if (parsedMessage.at("type") == "raw")
        {
            // The message contains a list of files to process.
            // For the case of the raw message, the list of files is always one, because it uses the consolidated file.
            if (parsedMessage.at("paths").size() != 1)
            {
                throw std::runtime_error("Invalid message");
            }
            // Delete all the data in the database, because the raw message contains all and latest data.
            m_feedDatabase->deleteAll();

            for (const auto& path : parsedMessage.at("paths"))
            {
                logDebug2(WM_VULNSCAN_LOGTAG, "Processing file: %s", path.get_ref<const std::string&>().c_str());
                std::ifstream file(path.get_ref<const std::string&>());
                if (!file.is_open())
                {
                    throw std::runtime_error("Unable to open input file: " + path.get_ref<const std::string&>());
                }

                std::string line;
                int32_t step = 0;
                // Parse the file and execute the chain/orchestration for each valid resource.
                // It orchestrate line by line.
                while (std::getline(file, line))
                {
                    if (m_shouldStop.load())
                    {
                        throw DatabaseFeedManagerException("Module stopped.");
                    }

                    if (step++ % 1000 == 0)
                    {
                        logDebug2(WM_VULNSCAN_LOGTAG, "Processing line: %d", step);
                    }

                    nlohmann::json parsedLine = nlohmann::json::parse(line, nullptr, false);
                    if (parsedLine.is_discarded() || !parsedLine.contains("name"))
                    {
                        throw std::runtime_error("Invalid line. file: " + path.get_ref<const std::string&>());
                    }

                    parsedLine["resource"] = parsedLine["name"];
                    parsedLine["type"] = "create";

                    orchestration(parsedLine, m_feedDatabase.get());
                }
            }

            m_feedDatabase->flush();

            // Update the offset.
            contentManagerUpdateOffset(topicName, parsedMessage.at("offset"));

            if (parsedMessage.contains("/fileMetadata/hash"_json_pointer))
            {
                // Update last parsed file hash.
                contentManagerUpdateHash(topicName,
                                         parsedMessage.at("fileMetadata").at("hash").get_ref<const std::string&>());
            }
        }
        else
        {
            throw std::runtime_error("Invalid message");
        }
    }

    /**
     * @brief Class constructor.
     *
     * @param indexerConnector Indexer connector.
     * @param shouldStop Variable to control the graceful shutdown of the module.
     * @param mutex Mutex to protect the access to the internal databases.
     * @param isLocalSubscriber Configures the router subscription lambda execution as local or remote.
     * @param reloadGlobalMapsStartup If true, the vendor and os cpe maps will be reloaded at startup.
     * @param initContentUpdater If true, the content updater will be initialized.
     * @param postUpdateCallback Callback to be executed after the update process.
     */
    // LCOV_EXCL_START
    explicit TDatabaseFeedManager(
        std::shared_ptr<TIndexerConnector> indexerConnector,
        const std::atomic<bool>& shouldStop,
        std::shared_mutex& mutex,
        const bool isLocalSubscriber = true,
        const bool reloadGlobalMapsStartup = true,
        const bool initContentUpdater = true,
        const std::function<void()>& postUpdateCallback =
            []() { // Not used
            })
        : Observer("database_feed_manager")
        , m_indexerConnector(std::move(indexerConnector))
        , m_shouldStop(shouldStop)
        , m_mutex(mutex)

    {
        const auto updaterPolicy = TPolicyManager::instance().getUpdaterConfiguration();
        const std::string topicName = updaterPolicy.at("topicName");

        try
        {
            m_feedDatabase = std::make_unique<TRocksDBWrapper>(DATABASE_PATH, false);

            // This initializes the vendor and os cpe maps and should be called before any scan or message processing.
            if (reloadGlobalMapsStartup)
            {
                // Try to load global maps from the database, if it fails we throw an exception to force the download of
                // the complete feed.
                reloadGlobalMaps();
            }
        }
        catch (const std::exception& ex)
        {
            // Create the database if it doesn't exist. We must remove any existing directory, as it may be corrupted.
            if (!m_feedDatabase)
            {
                std::filesystem::remove_all(DATABASE_PATH);
                m_feedDatabase = std::make_unique<TRocksDBWrapper>(DATABASE_PATH, false);
            }

            // Remove the updater directory to force the download of the complete feed.
            std::filesystem::remove_all(UPDATER_PATH);

            logError(WM_VULNSCAN_LOGTAG, "Error opening the database: %s, trying to re-download the feed.", ex.what());
        }

        // Subscription to vulnerability detector content update events.
        m_contentUpdateSubscription =
            std::make_unique<TRouterSubscriber>(topicName, "vulnerability_feed_manager", isLocalSubscriber);

        m_contentUpdateSubscription->subscribe(
            [&, topicName, postUpdateCallback]([[maybe_unused]] const std::vector<char>& message)
            {
                auto eventDecoder = std::make_shared<EventDecoder>();
                eventDecoder->setLast(std::make_shared<StoreModel>());
                eventDecoder->setLast(std::make_shared<FeedIndexer<TIndexerConnector>>(m_indexerConnector));

                auto orchestrationLambda = [&](const nlohmann::json& resource, Utils::IRocksDBWrapper* feedDatabaseArg)
                {
                    auto eventContext =
                        std::make_shared<EventContext>(EventContext {.message = message,
                                                                     .resource = resource,
                                                                     .feedDatabase = feedDatabaseArg,
                                                                     .resourceType = ResourceType::UNKNOWN});
                    eventDecoder->handleRequest(std::move(eventContext));
                };
                try
                {
                    logInfo(WM_VULNSCAN_LOGTAG, "Initiating update feed process.");
                    processMessage(message, topicName, orchestrationLambda);

                    // Verify vendor-map and oscpe-map values and update the maps in memory
                    reloadGlobalMaps();

                    // Dispatch the post update Callback
                    postUpdateCallback();
                    logInfo(WM_VULNSCAN_LOGTAG, "Feed update process completed.");
                }
                catch (const DatabaseFeedManagerException& e)
                {
                    logInfo(WM_VULNSCAN_LOGTAG, "Feed update interrupted: %s.", e.what());
                }
                catch (const std::exception& e)
                {
                    logError(WM_VULNSCAN_LOGTAG, "Error updating feed: %s, trying to re-download the feed.", e.what());

                    const std::string url = "http://localhost/ondemand/" + topicName + "?offset=0";
                    TUNIXSocketRequest::instance().get(
                        HttpUnixSocketURL(ONDEMAND_SOCK, url),
                        []([[maybe_unused]] const std::string&)
                        {
                            // Not used
                        },
                        [](const std::string& msg, const long responseCode)
                        { logError(WM_VULNSCAN_LOGTAG, "%s: %ld.", msg.c_str(), responseCode); });
                }
            });

        if (initContentUpdater)
        {
            // Vulnerability content updater initialization.
            m_contentRegistration =
                std::make_unique<TContentRegister>(topicName, TPolicyManager::instance().getUpdaterConfiguration());
        }
    }

    /**
     * @brief Retrieves vulnerability remediation information from the database, for a given CVE ID.
     *
     * This function retrieves remediation information associated with a given CVE ID
     * from the underlying database and stores it in the provided `dtoVulnRemediation`
     * object.
     *
     * @param cveId The CVE ID for which remediation information is requested.
     * @param dtoVulnRemediation A reference to a `FlatbufferDataPair` object
     *        where the retrieved remediation information will be stored.
     *
     * @throws std::runtime_error if the retrieved data from the database is invalid or
     *         not in the expected FlatBuffers format.
     */
    void getVulnerabilityRemediation(const std::string& cveId, FlatbufferDataPair<RemediationInfo>& dtoVulnRemediation)
    {
        // If the remediation information is not found in the database, we return because there is no remediation.
        if (auto result = m_feedDatabase->get(cveId, dtoVulnRemediation.slice, REMEDIATIONS_COLUMN); !result)
        {
            return;
        }

        if (flatbuffers::Verifier verifier(reinterpret_cast<const uint8_t*>(dtoVulnRemediation.slice.data()),
                                           dtoVulnRemediation.slice.size());
            !VerifyRemediationInfoBuffer(verifier))
        {
            throw std::runtime_error("Error: Invalid FlatBuffers data in RocksDB.");
        }

        dtoVulnRemediation.data = GetRemediationInfo(reinterpret_cast<const uint8_t*>(dtoVulnRemediation.slice.data()));
    }

    /**
     * @brief Retrieves the vulnerabilities information from the database, for a given hotfix ID.
     *
     * This function retrieves remediation information associated with a given hotfix from the underlying database and
     * stores it in the 'remediationInfo' object.
     *
     * @param hotfix hotfix id for which remediation information is requested.
     *
     * @return An unordered set containing the CVEs associated with the provided hotfix.
     *
     * @throws std::runtime_error if the retrieved data from the database is invalid or not in the expected FlatBuffers
     * format.
     */
    std::unordered_set<std::string> getHotfixVulnerabilities(const std::string& hotfix)
    {
        std::unordered_set<std::string> hotfixVulnerabilities;
        if (m_feedDatabase->columnExists(HOTFIXES_APPLICATIONS_COLUMN))
        {
            for (const auto& [key, value] : m_feedDatabase->seek(hotfix, HOTFIXES_APPLICATIONS_COLUMN))
            {
                hotfixVulnerabilities.insert(key);
            }
        }
        return hotfixVulnerabilities;
    }

    /**
     * @brief Fills the Level 2 cache with translations from the feed database.
     *
     * This function iterates over translations in the feed database, verifies the integrity of FlatBuffers
     * translation data, and inserts valid translations into the Level 2 cache.
     *
     * @throws std::runtime_error If invalid FlatBuffers translation data is encountered in the database.
     */
    void fillL2CacheTranslations()
    {
        // Clear the Level 1 and Level 2 cache before filling the Level 2 cache
        m_translationL1Cache->clear();

        m_translationL2Cache->clear();

        // Clear the translation filter before filling any cache
        m_translationFilter->clear();

        // Iterate over translations in the feed database
        for (const auto& [key, value] : m_feedDatabase->begin(TRANSLATIONS_COLUMN))
        {
            // Check if the cache is full
            if (m_translationL2Cache->isFull())
            {
                break; // Exit the loop if cache is full
            }

            // Verify the integrity of FlatBuffers translation data
            if (flatbuffers::Verifier verifier(reinterpret_cast<const uint8_t*>(value.data()), value.size());
                !VerifyTranslationEntryBuffer(verifier))
            {
                throw std::runtime_error("Error: Invalid FlatBuffers translation data in RocksDB.");
            }

            // Parse translation data
            auto queryData = GetTranslationEntry(reinterpret_cast<const uint8_t*>(value.data()));

            // Prepare regular expressions for product, vendor and version matching
            auto createRegex = [](const auto regex) -> std::optional<std::regex>
            {
                return regex && !regex->str().empty() ? std::optional<std::regex>(regex->str()) : std::nullopt;
            };

            // Initialize Translation object to store translation data
            Translation translationQuery = {.productRegex = createRegex(queryData->source()->product()),
                                            .vendorRegex = createRegex(queryData->source()->vendor()),
                                            .versionRegex = createRegex(queryData->source()->version())};

            // Load target platforms into the Translation object
            for (const auto& target : *queryData->target())
            {
                translationQuery.target.push_back(target->str());
            }

            // Load translation data into the Translation object
            for (const auto& translationData : *queryData->translation())
            {
                translationQuery.translation.emplace_back(
                    PackageData {.name = translationData->product() ? translationData->product()->str() : "",
                                 .vendor = translationData->vendor() ? translationData->vendor()->str() : "",
                                 .version = translationData->version() ? translationData->version()->str() : ""});
            }

            // Insert translation into cache
            m_translationL2Cache->insertKey(key, translationQuery);
        }
    }

    /**
     * @brief Retrieves translations from the Level 2 cache based on the provided package data and operating system
     * platform.
     *
     * This function searches the Level 2 cache for translations that match the provided package name, vendor and
     * operating system platform. If a translation matches the regex expressions, it is appended to the result vector.
     *
     * @param package A structure containing all the data for the package.
     * @param osPlatform The operating system platform for which translations are requested.
     * @return A vector containing the matching translations for the specified package and platform.
     */
    std::vector<PackageData> getTranslationFromL2(const PackageData& package, const std::string& osPlatform)
    {
        // Vector to store the resulting translations
        std::vector<PackageData> translationResult;

        // Iterate over the Level 2 cache data
        m_translationL2Cache->forEach(
            [&]([[maybe_unused]] const auto& key, const auto& cacheData)
            {
                /* Check conditions, return true to continue the loop, false to break it */
                // - The target platform matches the provided OS platform
                if (std::find(cacheData.target.begin(), cacheData.target.end(), osPlatform) == cacheData.target.end())
                {
                    return true;
                }
                // - The package name matches the product regex if present
                if (cacheData.productRegex.has_value() &&
                    !std::regex_search(package.name, cacheData.productRegex.value()))
                {
                    return true;
                }
                // - The vendor matches the vendor regex if present
                if (cacheData.vendorRegex.has_value() &&
                    !std::regex_search(package.vendor, cacheData.vendorRegex.value()))
                {
                    return true;
                }

                // Append the matching translation to the result vector
                for (const auto& translatedPackage : cacheData.translation)
                {
                    PackageData translatedResult {.name = translatedPackage.name, .vendor = translatedPackage.vendor};
                    // Search for version regex or use translated version
                    std::smatch stringFound;
                    if (cacheData.versionRegex.has_value() &&
                        std::regex_search(package.name, stringFound, cacheData.versionRegex.value()) &&
                        stringFound.size() > 0)
                    {
                        // We only consider the first capture group
                        translatedResult.version = stringFound.str(1);
                    }
                    else
                    {
                        translatedResult.version = translatedPackage.version;
                    }
                    translationResult.push_back(std::move(translatedResult));
                }

                // Break the loop after finding the first matching translation
                return false;
            });

        // Return the vector containing the matching translations
        return translationResult;
    }

    /**
     * @brief Get the Vulnerabilities Candidates information.
     *
     * @param cnaName RocksDB table identifier.
     * @param package Struct with package data.
     * @param callback Store vulnerability data.
     */
    void getVulnerabilitiesCandidates(
        const std::string& cnaName,
        const PackageData& package,
        const std::function<bool(const std::string& cnaName,
                                 const PackageData& package,
                                 const NSVulnerabilityScanner::ScanVulnerabilityCandidate&)>& callback)
    {
        if (package.name.empty() || cnaName.empty())
        {
            throw std::runtime_error("Invalid package/cna name.");
        }

        std::string packageNameWithSeparator;
        packageNameWithSeparator.append(package.name);
        packageNameWithSeparator.append("_CVE");

        for (const auto& [key, value] : m_feedDatabase->seek(packageNameWithSeparator, cnaName))
        {
            if (flatbuffers::Verifier verifier(reinterpret_cast<const uint8_t*>(value.data()), value.size());
                !NSVulnerabilityScanner::VerifyScanVulnerabilityCandidateArrayBuffer(verifier))
            {
                throw std::runtime_error(
                    "Error getting ScanVulnerabilityCandidateArray object from rocksdb. FlatBuffers verifier failed");
            }

            auto candidatesArray = GetScanVulnerabilityCandidateArray(reinterpret_cast<const uint8_t*>(value.data()));

            if (candidatesArray)
            {
                for (const auto& candidate : *candidatesArray->candidates())
                {
                    if (callback(cnaName, package, *candidate))
                    {
                        // If the candidate is vulnerable, we stop looking for.
                        break;
                    }
                }
            }
        }
    }

    /**
     * @brief Checks and translates package information.
     *
     * This function searches for translation data in the Level 1 and Level 2 caches for a given package.
     * If translation data is found, it populates the translations and returns them. If no translation data
     * is found, it logs a debug message and returns an empty vector.
     *
     * @param package The package data to be checked and translated.
     * @param osPlatform The operating system platform for which the package translation is required.
     * @return A vector containing the translated package data.
     */
    std::vector<PackageData> checkAndTranslatePackage(const PackageData& package, const std::string& osPlatform)
    {
        std::vector<PackageData> vulnerabilityTranslations;
        const auto cacheKey = osPlatform + "_" + package.vendor + "_" + package.name;

        auto translatePackage = [&](const auto& translations)
        {
            for (const auto& translation : translations)
            {
                PackageData translatedPackage = package;
                if (!translation.name.empty())
                {
                    translatedPackage.name = translation.name;
                }
                if (!translation.vendor.empty())
                {
                    translatedPackage.vendor = translation.vendor;
                }
                if (!translation.version.empty())
                {
                    translatedPackage.version = translation.version;
                }
                vulnerabilityTranslations.push_back(translatedPackage);
            }
        };

        // Check first the filter
        if (m_translationFilter->count(cacheKey) > 0)
        {
            logDebug2(WM_VULNSCAN_LOGTAG,
                      "No translation exists for package '%s' on platform '%s'. Using provided package data.",
                      package.name.c_str(),
                      osPlatform.c_str());
            return vulnerabilityTranslations;
        }

        // Check Level 1 cache
        if (m_translationL1Cache->isHit(cacheKey))
        {
            logDebug2(WM_VULNSCAN_LOGTAG,
                      "Translation for package '%s' on platform '%s' found in Level 1 cache.",
                      package.name.c_str(),
                      osPlatform.c_str());

            const auto& L1Translations = m_translationL1Cache->getValue(cacheKey).value();
            translatePackage(L1Translations);
            return vulnerabilityTranslations;
        }

        // Check Level 2 cache
        const auto L2Translations = getTranslationFromL2(package, osPlatform);
        if (!L2Translations.empty())
        {
            logDebug2(WM_VULNSCAN_LOGTAG,
                      "Translation for package '%s' on platform '%s' found in Level 2 cache.",
                      package.name.c_str(),
                      osPlatform.c_str());

            translatePackage(L2Translations);

            // Store translations in Level 1 cache
            m_translationL1Cache->insertKey(cacheKey, L2Translations);
            return vulnerabilityTranslations;
        }

        // Insert the key in the filter to avoid searching for it again
        m_translationFilter->insert(cacheKey);
        logDebug2(WM_VULNSCAN_LOGTAG,
                  "No translation exists for package '%s' on platform '%s'. Using provided package data.",
                  package.name.c_str(),
                  osPlatform.c_str());

        return vulnerabilityTranslations;
    }

    /**
     * @brief Retrieves a reference to the CVE (Common Vulnerabilities and Exposures) database.
     *
     * This function provides access to the Common Vulnerabilities and Exposures (CVE) database
     * represented by a reference to a RocksDBWrapper object.
     *
     * @return A reference to the CVE database represented by TRocksDBWrapper.
     */
    TRocksDBWrapper& getCVEDatabase()
    {
        return *m_feedDatabase;
    }

    /**
     * @brief Updates scheduler interval.
     *
     * @param data Data containing the interval.
     */
    void update(nlohmann::json& data) override
    {
        if (m_contentRegistration)
        {
            m_contentRegistration->changeSchedulerInterval(data.at("updater").at("interval").get<size_t>());
        }
    }
    // LCOV_EXCL_STOP

    /**
     * @brief Gets descriptive information for a cveid.
     *
     * @param cveId cveid to search.
     * @param resultContainer container struct to store the result.
     */
    void getVulnerabiltyDescriptiveInformation(const std::string_view cveId,
                                               FlatbufferDataPair<VulnerabilityDescription>& resultContainer)
    {
        if (m_feedDatabase->get(std::string(cveId), resultContainer.slice, DESCRIPTIONS_COLUMN) == false)
        {
            throw std::runtime_error(
                "Error getting VulnerabilityDescription object from rocksdb. Object not found for cveId: " +
                std::string(cveId));
        }

        if (flatbuffers::Verifier verifier(reinterpret_cast<const uint8_t*>(resultContainer.slice.data()),
                                           resultContainer.slice.size());
            NSVulnerabilityScanner::VerifyVulnerabilityDescriptionBuffer(verifier) == false)
        {
            throw std::runtime_error(
                "Error getting VulnerabilityDescription object from rocksdb. FlatBuffers verifier failed");
        }

        resultContainer.data = const_cast<NSVulnerabilityScanner::VulnerabilityDescription*>(
            NSVulnerabilityScanner::GetVulnerabilityDescription(resultContainer.slice.data()));
    }

    /**
     * @brief Get CNA/ADP name based on the package source.
     *
     * @param source Package source.
     * @return std::string CNA/ADP name. Empty string otherwise.
     */
    std::string getCnaNameBySource(std::string_view source) const
    {
        if (const auto& vendorMap = GlobalData::instance().vendorMaps(); vendorMap.contains("source"))
        {
            for (const auto& item : vendorMap.at("source"))
            {
                if (source == item.begin().key())
                {
                    return item.begin().value();
                }
            }
        }

        return {};
    }

    /**
     * @brief Get CNA/ADP name based on the package format.
     * @param format Package format.
     * @return CNA/ADP name. Empty string otherwise.
     */
    std::string getCnaNameByFormat(std::string_view format) const
    {
        if (const auto& vendorMap = GlobalData::instance().vendorMaps(); vendorMap.contains("format"))
        {
            for (const auto& item : vendorMap.at("format"))
            {
                if (format == item.begin().key())
                {
                    return item.begin().value();
                }
            }
        }

        return {};
    }

    /**
     * @brief Get CNA/ADP name based on the package vendor when it contains a specific word.
     * @param vendor Package vendor.
     * @param platform Os platform.
     * @return CNA/ADP name. Empty string otherwise.
     */
    std::string getCnaNameByContains(std::string_view vendor, std::string_view platform) const
    {
        if (const auto& vendorMap = GlobalData::instance().vendorMaps(); vendorMap.contains("contains"))
        {
            for (const auto& item : vendorMap.at("contains"))
            {
                if (const auto& platforms = item.begin().value().at("platforms");
                    vendor.find(item.begin().key()) != std::string::npos &&
                    std::find(platforms.begin(), platforms.end(), platform) != platforms.end())
                {
                    return item.begin().value().at("cna");
                }
            }
        }

        return {};
    }

    /**
     * @brief Get CNA/ADP name based on the package vendor when it starts with a specific word.
     * @param vendor Package vendor.
     * @param platform Os platform.
     *
     * @return CNA/ADP name. Empty string otherwise.
     */
    std::string getCnaNameByPrefix(std::string_view vendor, std::string_view platform) const
    {
        if (const auto& vendorMap = GlobalData::instance().vendorMaps(); vendorMap.contains("prefix"))
        {
            for (const auto& item : vendorMap.at("prefix"))
            {
                if (const auto& platforms = item.begin().value().at("platforms");
                    Utils::startsWith(vendor.data(), item.begin().key()) &&
                    std::find(platforms.begin(), platforms.end(), platform) != platforms.end())
                {
                    return item.begin().value().at("cna");
                }
            }
        }

        return {};
    }

    /**
     * @brief Get cache size from configuration.
     *
     * This function retrieves the cache size for translation cache from the configuration settings.
     * It accesses the instance of TPolicyManager to fetch the translation LRU size specified in the configuration.
     *
     * @return The size of the translation cache as specified in the configuration settings.
     */
    uint32_t getCacheSizeFromConfig() const
    {
        return TPolicyManager::instance().getTranslationLRUSize();
    }

private:
    /**
     * Do not change the order of definition of these variables.
     * Since it is important at the object destruction time.
     */
    std::shared_mutex& m_mutex;
    std::shared_ptr<TIndexerConnector> m_indexerConnector;
    std::unique_ptr<TContentRegister> m_contentRegistration;
    std::unique_ptr<TRocksDBWrapper> m_feedDatabase;
    std::unique_ptr<TranslationLRUCache> m_translationL2Cache =
        std::make_unique<TranslationLRUCache>(TPolicyManager::instance().getTranslationLRUSize());

    std::unique_ptr<std::unordered_set<std::string>> m_translationFilter =
        std::make_unique<std::unordered_set<std::string>>();
    std::unique_ptr<LRUCache<std::string, std::vector<PackageData>>> m_translationL1Cache =
        std::make_unique<LRUCache<std::string, std::vector<PackageData>>>(
            TPolicyManager::instance().getTranslationLRUSize());
    std::unique_ptr<TRouterSubscriber> m_contentUpdateSubscription;
    const std::atomic<bool>& m_shouldStop;

    void contentManagerUpdateOffset(const std::string& topicName, const long long currentOffset) const
    {
        nlohmann::json data;
        data["offset"] = currentOffset;
        data["topicName"] = topicName;

        // Exclude from coverage because need to be tested in integration tests.
        // LCOV_EXCL_START
        TUNIXSocketRequest::instance().put(
            HttpUnixSocketURL(ONDEMAND_SOCK, "http://localhost/offset"),
            data,
            []([[maybe_unused]] const std::string&)
            {
                // Not used
            },
            [](const std::string& msg, const long) { throw std::runtime_error("Error updating offset: " + msg); });
        // LCOV_EXCL_STOP
    }

    /**
     * @brief Makes the Content Manager to update the last parsed file hash value so that redundant processing is
     * avoided.
     *
     * @param topicName Topic name.
     * @param fileHash Value of the hash to be used in the update.
     */
    void contentManagerUpdateHash(const std::string& topicName, const std::string& fileHash) const
    {
        constexpr auto URL {"http://localhost/hash"};
        nlohmann::json data;
        data["hash"] = fileHash;
        data["topicName"] = topicName;

        // Exclude from coverage because need to be tested in integration tests.
        // LCOV_EXCL_START
        TUNIXSocketRequest::instance().put(
            HttpUnixSocketURL(ONDEMAND_SOCK, URL),
            std::move(data),
            [](const std::string& msg) {},
            [](const std::string& msg, const long responseCode)
            { throw std::runtime_error("Error updating file hash: " + msg); });
        // LCOV_EXCL_STOP
    }

    /**
     * @brief Reads the vendor and os cpe maps from the database and loads the data into memory.
     *
     * @throws std::runtime_error if the vendor and os cpe maps aren't available or are invalid.
     * @note This methods locks the mutex.
     */
    void reloadGlobalMaps()
    {
        std::scoped_lock<std::shared_mutex> lock(m_mutex);

        std::string result;
        if (!m_feedDatabase->get("FEED-GLOBAL", result, VENDOR_MAP_COLUMN))
        {
            throw std::runtime_error("Vendor map can not be found in DB.");
        }
        else if (result.empty())
        {
            throw std::runtime_error("Vendor map is empty.");
        }

        GlobalData::instance().vendorMaps(nlohmann::json::parse(result));

        rocksdb::PinnableSlice queryResult;
        if (!m_feedDatabase->get("OSCPE-GLOBAL", queryResult, OS_CPE_RULES_COLUMN))
        {
            throw std::runtime_error("Error getting OS CPE rules content from rocksdb.");
        }
        GlobalData::instance().osCpeMaps(nlohmann::json::parse(queryResult.ToString()));

        // Load CNA mappings
        if (!m_feedDatabase->get("CNA-MAPPING-GLOBAL", queryResult, CNA_MAPPING_COLUMN))
        {
            throw std::runtime_error("Error getting CNA Mapping content from rocksdb.");
        }
        GlobalData::instance().cnaMappings(nlohmann::json::parse(queryResult.ToString()));

        // Load translations into the Level 2 cache
        fillL2CacheTranslations();
    }
};

using DatabaseFeedManager = TDatabaseFeedManager<>;

#endif // _DATABASE_FEED_MANAGER_HPP
