# Copyright (C) 2015, Wazuh Inc.
# Created by Wazuh, Inc. <info@wazuh.com>.
# This program is free software; you can redistribute it and/or modify it under the terms of GPLv2

import json
import subprocess
import os
import time
from pathlib import Path
import logging
import re
import pytest

from helpers import tail_log, find_regex_in_file

LOGGER = logging.getLogger(__name__)
MAX_RETRY = 3

@pytest.fixture
def runner_function(request, run_on_end):
    """
    Function to run tests for policy change.

    Args:
        request: The request object containing the test parameters.
        run_on_end: Fixture to run at the end of the test.

    Returns:
        A dictionary containing the lines found during the test.

    Raises:
        AssertionError: If any of the assertions fail.
    """
    # Delete previous inventory directory if exists
    if Path("queue/vd/inventory").exists():
        for file in Path("queue/vd/inventory").glob("*"):
            file.unlink()
        Path("queue/vd/inventory").rmdir()

    if Path("queue/indexer/wazuh-states-vulnerabilities").exists():
        for file in Path("queue/indexer/wazuh-states-vulnerabilities").glob("*"):
            file.unlink()
        Path("queue/indexer/wazuh-states-vulnerabilities").rmdir()

    # Set the path to the binary
    cmd = Path("build/wazuh_modules/vulnerability_scanner/testtool/scanner/", "vd_scanner_testtool")
    cmd_alt = Path("wazuh_modules/vulnerability_scanner/build/testtool/scanner/", "vd_scanner_testtool")

    # Ensure the binary exists
    if not cmd.exists():
        cmd = cmd_alt
    assert cmd.exists(), "The binary does not exists"

    # Remove previous log file if exists
    if Path("log.out").exists():
        Path("log.out").unlink()

    test_folder = request.param
    LOGGER.debug(f"Running test {test_folder}")

    json_files = sorted(Path(test_folder).glob("args_*.json"))
    for json_file in json_files:
        LOGGER.debug(f"Running test {json_file}")

        # Read arguments from the json file
        with open(json_file) as f:
            args = json.load(f)

        command = [cmd] + args

        found_lines = {}
        with subprocess.Popen(command) as process:
            start_time = time.time()
            log_file = "log.out"

            while not Path(log_file).exists() and (time.time() - start_time <= 10):
                time.sleep(1)

            # Check if the log file exists, if the line is not found, try again in 1 second
            assert Path(log_file).exists(), "The log file does not exists"

            # Check if the process is initialized
            LOGGER.debug("Waiting for the process to be initialized")
            found = find_regex_in_file(r"Vulnerability scanner module (started|is disabled)", log_file, LOGGER)
            assert found, "The process is not initialized"
            LOGGER.info("Process initialized")

            # Regex to extract the value of the *** in args_***.json
            regex = r"args_(\d+).json"
            match = re.search(regex, json_file.name)
            assert match, "The regex does not match"
            expected_json_file = Path(test_folder, f"expected_{match.group(1)}.out")
            assert expected_json_file.exists(), "The expected file does not exists"

            expected_lines = []

            json_data = json.load(open(expected_json_file))
            LOGGER.debug(f"Expected json data: {json_data}")
            for line in json_data:
                expected_lines.append(line)

            LOGGER.debug(f"Expected lines: {expected_lines}")
            quantity_expected_lines = len(expected_lines)
            LOGGER.debug(f"Quantity expected lines: {quantity_expected_lines}")

            found_lines = {line: False for line in expected_lines}
            timeout = 10

            retry = 0
            for expected_line in expected_lines:
                while not found_lines[expected_line]:
                    LOGGER.debug(f"Waiting for: {expected_line}")
                    if retry < MAX_RETRY:
                        tail_log(log_file, expected_lines, found_lines, timeout, LOGGER)
                        retry += 1
                    else:
                        LOGGER.error(f"Timeout waiting for: {expected_line}")
                        retry = 0
                        break

            # Wait for the process to finish, sigterm is sent to the process
            process.terminate()
            LOGGER.debug("Waiting for the process to finish")

    return found_lines

test_folders = sorted(Path("wazuh_modules/vulnerability_scanner/qa/test_data_policy").glob(os.getenv('WAZUH_VD_TEST_GLOB', '*')))

@pytest.mark.parametrize("runner_function", test_folders, indirect=True)
def test_configuration_change(runner_function):
    """
    Test the configuration change by running the provided runner function.

    Args:
        runner_function: A function that runs the binary and returns a dictionary of found lines.

    Raises:
        AssertionError: If the expected output is not found in the dictionary of found lines.
    """

    # change working directory to the root of the project parent directory
    # This is required to run the binary
    os.chdir(Path(__file__).parent.parent.parent.parent)

    found_lines = runner_function
    for line, found in found_lines.items():
        if not found:
            LOGGER.error(f"Log entry not found: {line}")
    assert all(found_lines.values()), "The test is failed because the expected output is not found"
