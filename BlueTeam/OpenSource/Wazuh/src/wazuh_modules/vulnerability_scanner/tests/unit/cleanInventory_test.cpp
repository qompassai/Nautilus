/*
 * Wazuh Vulnerability Scanner - Unit Tests
 * Copyright (C) 2015, Wazuh Inc.
 * September 21, 2023.
 *
 * This program is free software; you can redistribute it
 * and/or modify it under the terms of the GNU General Public
 * License (version 2) as published by the FSF - Free Software
 * Foundation.
 */

#include "cleanInventory_test.hpp"
#include "../../../../shared_modules/utils/flatbuffers/include/syscollector_deltas_generated.h"
#include "../../../../shared_modules/utils/flatbuffers/include/syscollector_deltas_schema.h"
#include "../../../../shared_modules/utils/flatbuffers/include/syscollector_synchronization_generated.h"
#include "../../../../shared_modules/utils/flatbuffers/include/syscollector_synchronization_schema.h"
#include "../scanOrchestrator/cleanInventory.hpp"
#include "MockOsDataCache.hpp"
#include "TrampolineOsDataCache.hpp"
#include "TrampolineRemediationDataCache.hpp"
#include "flatbuffers/flatbuffer_builder.h"
#include "flatbuffers/flatbuffers.h"
#include "flatbuffers/idl.h"
#include "json.hpp"
#include "mocks/chainOfResponsabilityMock.h"

using ::testing::_;

namespace NSCleanInventoryTest
{
    constexpr auto TEST_INVENTORY_DATABASE_PATH {"queue/vd/inventory"};

    const std::string SYNCHRONIZATION_INTEGRITY_CLEAR_MSG =
        R"(
            {
                "agent_info": {
                    "agent_id": "001",
                    "agent_ip": "192.168.33.20",
                    "agent_name": "focal"
                },
                "data_type": "integrity_clear",
                "data": {
                    "id": 1700236640,
                    "attributes_type": "syscollector_packages"
                }
            }
        )";

    const std::string CVEID1 {"CVE-2024-5678"};
    const std::string CVEID2 {"CVE-2023-5362"};
} // namespace NSCleanInventoryTest

using namespace NSCleanInventoryTest;

void CleanInventoryTest::SetUp()
{
    m_inventoryDatabase = std::make_unique<Utils::RocksDBWrapper>(TEST_INVENTORY_DATABASE_PATH);
    for (const auto& element : AFFECTED_COMPONENT_COLUMNS)
    {
        if (!m_inventoryDatabase->columnExists(element.second))
        {
            m_inventoryDatabase->createColumn(element.second);
        }
    }

    if (!m_inventoryDatabase->columnExists(OS_INITIAL_SCAN))
    {
        m_inventoryDatabase->createColumn(OS_INITIAL_SCAN);
    }
}

void CleanInventoryTest::TearDown()
{
    spOsDataCacheMock.reset();
    spRemediationDataCacheMock.reset();
    m_inventoryDatabase->deleteAll();
    m_inventoryDatabase.reset();
    std::filesystem::remove_all(TEST_INVENTORY_DATABASE_PATH);
}

/*
 * @brief Test instantiation of the eventInsertInventory class.
 */
TEST_F(CleanInventoryTest, TestInstantiationOfTheeventInsertInventoryClass)
{
    // Instantiation of the eventInsertInventory class.
    using scanContext_t = TScanContext<TrampolineOsDataCache, GlobalData, TrampolineRemediationDataCache>;
    EXPECT_NO_THROW(std::make_shared<TCleanInventory<scanContext_t>>(*m_inventoryDatabase, nullptr));
}

/*
 * @brief Test handleRequest of the eventInsertInventory class (Integrity Clear).
 */
TEST_F(CleanInventoryTest, TestCleanAllData)
{
    // Created dummy data.
    m_inventoryDatabase->put("001_aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa", "CVE-1234-2024,CVE-4321-2024", PACKAGE);
    m_inventoryDatabase->put("001_bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb", "CVE-1234-2024,CVE-4321-2024", OS);
    m_inventoryDatabase->put("002_cccccccccccccccccccccccccccccccccccccccc", "CVE-1234-2024,CVE-4321-2024", OS);
    m_inventoryDatabase->put("001", "1", OS_INITIAL_SCAN);
    m_inventoryDatabase->put("002", "2", OS_INITIAL_SCAN);

    auto spSubOrchestration = std::make_shared<MockAbstractHandler<
        std::shared_ptr<TScanContext<TrampolineOsDataCache, GlobalData, TrampolineRemediationDataCache>>>>();
    EXPECT_CALL(*spSubOrchestration, handleRequest(testing::_)).Times(6);

    auto cleanInventory = std::make_shared<
        TCleanInventory<TScanContext<TrampolineOsDataCache, GlobalData, TrampolineRemediationDataCache>,
                        MockAbstractHandler<std::shared_ptr<
                            TScanContext<TrampolineOsDataCache, GlobalData, TrampolineRemediationDataCache>>>>>(
        *m_inventoryDatabase, spSubOrchestration);

    nlohmann::json jsonData = nlohmann::json::parse(
        R"({"agent_info":  {"agent_id":"001",  "agent_version":"4.8.0",  "agent_name":"test_agent_name",
"agent_ip":"10.0.0.1"},  "action":"upgradeAgentDB"})");

    std::variant<const SyscollectorDeltas::Delta*, const SyscollectorSynchronization::SyncMsg*, const nlohmann::json*>
        data = &jsonData;
    auto context =
        std::make_shared<TScanContext<TrampolineOsDataCache, GlobalData, TrampolineRemediationDataCache>>(data);

    EXPECT_NO_THROW(cleanInventory->handleRequest(context));

    // Check if the inventory was deleted.
    std::string value;
    EXPECT_FALSE(m_inventoryDatabase->get("001_aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa", value, PACKAGE));
    EXPECT_FALSE(m_inventoryDatabase->get("001_bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb", value, OS));
    EXPECT_FALSE(m_inventoryDatabase->get("002_cccccccccccccccccccccccccccccccccccccccc", value, OS));
    EXPECT_FALSE(m_inventoryDatabase->get("001", value, OS_INITIAL_SCAN));
    EXPECT_FALSE(m_inventoryDatabase->get("002", value, OS_INITIAL_SCAN));
}
