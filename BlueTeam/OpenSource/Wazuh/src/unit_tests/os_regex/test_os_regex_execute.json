[
    {
        "description": "[Functionality] Charmap without backslashed tokens.",
        "batch_test": [
            {
                "description": "Literal match. Match all.",
                "pattern": "hi Wazuh",
                "log": "hi Wazuh",
                "end_match": "h",
                "captured_groups": []
            },
            {
                "description": "Literal match. Match all, with capture groups.",
                "pattern": "(hi) (Wazuh)",
                "log": "hi Wazuh",
                "end_match": "h",
                "captured_groups": [
                    "hi",
                    "Wazuh"
                ]
            },
            {
                "description": "Literal match, with the end flag. It does not match.",
                "pattern": "hi Wazuh$",
                "log": "hi Wazuh 123",
                "end_match": null,
                "captured_groups": []
            },
            {
                "description": "Literal match, with groups and the end flag. It does not match.",
                "pattern": "(hi) (Wazuh)$",
                "log": "hi Wazuh 123",
                "end_match": null,
                "captured_groups": []
            },
            {
                "description": "Dont match at all.",
                "pattern": "hi Wazuh",
                "log": "bye Wazuh",
                "end_match": null,
                "captured_groups": []
            },
            {
                "description": "Match with prefix and group.",
                "pattern": "(hi) (Wazuh)",
                "log": "prefixhi Wazuh",
                "end_match": "h",
                "captured_groups": [
                    "hi",
                    "Wazuh"
                ]
            },
            {
                "description": "Match with sufix and group.",
                "pattern": "(hi) (Wazuh)",
                "log": "fixhi Wazuhsub",
                "end_match": "hsub",
                "captured_groups": [
                    "hi",
                    "Wazuh"
                ]
            },
            {
                "description": "Match with adjacent capture groups.",
                "__known_issue": "It should match but does not, adjacent capture groups are not supported. BUG 1 of issue: https://github.com/wazuh/wazuh/issues/14420",
                "ignore_result": true,
                "pattern": "(hi)(Wazuh)",
                "log": "hiWazuh",
                "end_match": "h",
                "captured_groups": [
                    "hi",
                    "Wazuh"
                ]
            },
            {
                "description": "Match with adjacent capture groups and context.",
                "__known_issue": "It should match but does not, adjacent capture groups are not supported. BUG 1 of issue: https://github.com/wazuh/wazuh/issues/14420",
                "ignore_result": true,
                "pattern": "(hi)(Wazuh)",
                "log": "prefixhiWazuhsub",
                "end_match": "hsub",
                "captured_groups": [
                    "hi",
                    "Wazuh"
                ]
            }
        ]
    },
    {
        "description": "[Functionality] Charmap + END/BEGIN flags and st_error without backslashed tokens.",
        "batch_test": [
            {
                "description": "Regex match all and the END_SET is set.",
                "pattern": "hi Wazuh$",
                "log": "hi Wazuh",
                "end_match": "h",
                "captured_groups": []
            },
            {
                "description": "Empty pattern END_SET and BEGIN_SET are set.",
                "pattern": "^$",
                "log": "hi Wazuh",
                "end_match": null,
                "captured_groups": []
            },
            {
                "description": "Empty pattern END_SET and BEGIN_SET are set.",
                "__known_issue": "It should match but does not, it is not possible to check if a log is empty.",
                "pattern": "^$",
                "log": "",
                "end_match": "",
                "captured_groups": []
            },
            {
                "description": "Empty pattern END_SET and BEGIN_SET are set.",
                "__known_issue": "It should match but does not, it is not possible to check if a log is empty.",
                "ignore_result": true,
                "pattern": "(^$)",
                "log": "",
                "end_match": "",
                "captured_groups": [
                    ""
                ]
            },
            {
                "description": "Empty pattern END_SET and BEGIN_SET are set.",
                "__known_issue": "It should match but does not, it is not possible to check if a log is empty. BUG 2 of issue: https://github.com/wazuh/wazuh/issues/14420",
                "ignore_result": true,
                "pattern": "^()$",
                "log": "",
                "end_match": "",
                "captured_groups": [
                    ""
                ]
            },
            {
                "description": "Pattern ends and the END_SET is not set.",
                "pattern": "hi Wazuh",
                "log": "hi Wazuh!",
                "end_match": "h!",
                "captured_groups": []
            },
            {
                "description": "Partial match and then re-match ('st_error' test).",
                "pattern": "(hi) (Wazuh)",
                "log": "XX hi Wa hi WazuhXX",
                "end_match": "hXX",
                "captured_groups": [
                    "hi",
                    "Wazuh"
                ]
            },
            {
                "description": "Partial match and then re-match ('st_error' + BEGIN_SET test).",
                "pattern": "^(hi) (Wazuh)",
                "log": "hi Wa hi WazuhXX",
                "end_match": null,
                "captured_groups": []
            }
        ]
    },
    {
        "description": "[Functionality] Only backslashed tokens without quantifiers ('*', '+').",
        "batch_test": [
            {
                "description": "Match all.",
                "pattern": "\\w\\w\\s\\S\\S\\S\\S\\S",
                "log": "hi Wazuh",
                "end_match": "h",
                "captured_groups": []
            },
            {
                "description": "Parcial match and fail",
                "pattern": "\\w\\w\\s\\S\\S\\S\\S\\S",
                "log": "hi Waz",
                "end_match": null,
                "captured_groups": []
            },
            {
                "description": "Parcial match and fail and then re-match",
                "pattern": "\\w\\w\\s\\S\\S\\S\\S\\S",
                "log": "hi Waz hi Wazu.",
                "end_match": ".",
                "captured_groups": []
            },
            {
                "description": "Match all with capture groups.",
                "pattern": "\\w(\\w\\s\\S)\\S(\\S\\S\\S)",
                "log": "hi Wazuh",
                "end_match": "h",
                "captured_groups": [
                    "i W",
                    "zuh"
                ]
            },
            {
                "description": "Parcial match and fail  with capture group.",
                "pattern": "(\\w\\w)\\s\\S\\S\\S\\S\\S",
                "log": "hi Waz",
                "end_match": null,
                "captured_groups": []
            },
            {
                "description": "Parcial match and fail but then re-match with capture group.",
                "pattern": "(\\w\\w)\\s(\\S\\S\\S\\S\\S)",
                "log": "hi Waz hi Wazuh.",
                "end_match": "h.",
                "captured_groups": [
                    "hi",
                    "Wazuh"
                ]
            },
            {
                "description": "Parcial match and fail but then re-match with adjacent capture group.",
                "__known_issue": "It should match but does not, adjacent capture groups are not supported. BUG 1 of issue: https://github.com/wazuh/wazuh/issues/14420",
                "ignore_result": true,
                "pattern": "(\\w\\w\\s)(\\S\\S\\S\\S\\S)",
                "log": "hi Waz hi Wazuh.",
                "end_match": "h.",
                "captured_groups": [
                    "hi ",
                    "Wazuh"
                ]
            },
            {
                "description": "Parcial match and fail but then re-match with one capture group.",
                "pattern": "(\\w\\w\\s\\S\\S\\S\\S\\S)\\p$",
                "log": "hi Waz hi Wazuh.",
                "end_match": ".",
                "captured_groups": [
                    "hi Wazuh"
                ]
            }
        ]
    },
    {
        "description": "[Functionality] Only backslashed tokens with the '+' quantifier.",
        "batch_test": [
            {
                "description": "Match all.",
                "__known_issue": "Matches but if the regex ends with a token with the quantifier '+' or '*', then it does not return the pointer to the last character matched, as it should be. BUG 3 of issue: https://github.com/wazuh/wazuh/issues/14420",
                "ignore_result": true,
                "pattern": "\\w+",
                "log": "Wazuh",
                "end_match": "h",
                "captured_groups": []
            },
            {
                "description": "Mach all with capture group.",
                "__known_issue": "Matches but if the regex ends with a token with the quantifier '+' or '*', then it does not return the pointer to the last character matched, as it should be. BUG 3 of issue: https://github.com/wazuh/wazuh/issues/14420",
                "ignore_result": true,
                "pattern": "(\\w+)",
                "log": "Wazuh",
                "end_match": "h",
                "captured_groups": [
                    "Wazuh"
                ]
            },
            {
                "description": "Mach all with capture group and flags.",
                "__known_issue": "Matches but if the regex ends with a token with the quantifier '+' or '*', then it does not return the pointer to the last character matched, as it should be. BUG 3 of issue: https://github.com/wazuh/wazuh/issues/14420",
                "ignore_result": true,
                "debug": false,
                "pattern": "^\\w+$",
                "log": "Wazuh",
                "end_match": "h",
                "captured_groups": []
            },
            {
                "description": "Mach all with capture group and flags.",
                "ignore_result": true,
                "debug": false,
                "pattern": "^(\\w+)$",
                "log": "Wazuh",
                "end_match": "h",
                "captured_groups": [
                    "Wazuh"
                ]
            },
            {
                "description": "Parcial match and fail, with flags.",
                "pattern": "^\\w+$",
                "log": "Wazuh ",
                "end_match": null,
                "captured_groups": []
            },
            {
                "description": "Parcial match and fail with capture group and flags.",
                "pattern": "^(\\w+)$",
                "log": "Wazuh ",
                "end_match": null,
                "captured_groups": []
            },
            {
                "description": "Match one character.",
                "pattern": "\\w+",
                "log": "w",
                "end_match": "w",
                "captured_groups": []
            },
            {
                "description": "Match one character, with capture group.",
                "pattern": "(\\w+)",
                "log": "w",
                "end_match": "w",
                "captured_groups": [
                    "w"
                ]
            },
            {
                "description": "Match one character and flags.",
                "pattern": "^\\w+$",
                "log": "w",
                "end_match": "w",
                "captured_groups": []
            },
            {
                "description": "Match one character, with capture group and flags",
                "pattern": "^(\\w+)$",
                "log": "w",
                "end_match": "w",
                "captured_groups": [
                    "w"
                ]
            }
        ]
    },
    {
        "description": "[Functionality] Lazy-Greedy behavior duality: Regex composed by a backslashed token with a '+' quantifier followed by a token that has no quantifier, where the last token does not include the charmap of the first one.",
        "batch_test": [
            {
                "description": "Minimun log to match all, with backslashed token.",
                "pattern": "\\w+\\s",
                "log": "X ",
                "end_match": " ",
                "captured_groups": []
            },
            {
                "description": "Match all, with backslashed token.",
                "pattern": "\\w+\\s",
                "log": "Wazuh ",
                "end_match": " ",
                "captured_groups": []
            },
            {
                "description": "Minimun log to match all with capture group, with backslashed token.",
                "pattern": "(\\w+)\\s",
                "log": "X ",
                "end_match": " ",
                "captured_groups": [
                    "X"
                ]
            },
            {
                "description": "Minimun log to match and capture all, with backslashed token.",
                "pattern": "(\\w+\\s)",
                "log": "w ",
                "end_match": " ",
                "captured_groups": [
                    "w "
                ]
            },
            {
                "description": "Match all, capture the first token, with backslashed token.",
                "pattern": "(\\w+)\\s",
                "log": "Wazuh ",
                "end_match": " ",
                "captured_groups": [
                    "Wazuh"
                ]
            },
            {
                "description": "Minimun log to match all.",
                "pattern": "\\w+ ",
                "log": "w ",
                "end_match": " ",
                "captured_groups": []
            },
            {
                "description": "Match all.",
                "pattern": "\\w+ ",
                "log": "Wazuh ",
                "end_match": " ",
                "captured_groups": []
            },
            {
                "description": "Minimun log to match all with capture group.",
                "pattern": "(\\w+) ",
                "log": "w ",
                "end_match": " ",
                "captured_groups": [
                    "w"
                ]
            },
            {
                "description": "Minimun log to match and capture all.",
                "pattern": "(\\w+ )",
                "log": "w ",
                "end_match": " ",
                "captured_groups": [
                    "w "
                ]
            },
            {
                "description": "Match all and capture the first word.",
                "pattern": "(\\w+) ",
                "log": "Wazuh ",
                "end_match": " ",
                "captured_groups": [
                    "Wazuh"
                ]
            },
            {
                "description": "Match all, with a literal at the end.",
                "pattern": "\\w+\\s1",
                "log": "Wazuh 1",
                "end_match": "1",
                "captured_groups": []
            },
            {
                "description": "Minimun log to match all, with a literal at the end, capture the first word.",
                "pattern": "(\\w+)\\s1",
                "log": "w 1",
                "end_match": "1",
                "captured_groups": [
                    "w"
                ]
            },
            {
                "description": "Match all, with a literal at the end, capture the first word and the second token (space).",
                "pattern": "(\\w+\\s)1",
                "log": "w 1",
                "end_match": "1",
                "captured_groups": [
                    "w "
                ]
            },
            {
                "description": "Match all, with a literal at the end, capture the first word.",
                "pattern": "(\\w+)\\s1",
                "log": "Wazuh 1",
                "end_match": "1",
                "captured_groups": [
                    "Wazuh"
                ]
            },
            {
                "description": "Match, with a postfix.",
                "pattern": "\\w+\\s1",
                "log": "w 123",
                "end_match": "123",
                "captured_groups": []
            },
            {
                "description": "Match, with a postfix and a literal space",
                "pattern": "\\w+ 1",
                "log": "Wazuh 123",
                "end_match": "123",
                "captured_groups": []
            },
            {
                "description": "Match, with a postfix and a literal space, capture the first token.",
                "pattern": "(\\w+) 1",
                "log": "w 123",
                "end_match": "123",
                "captured_groups": [
                    "w"
                ]
            },
            {
                "description": "Match, with a postfix and a literal space, capture the first token and the space.",
                "pattern": "(\\w+ )1",
                "log": "w 123",
                "end_match": "123",
                "captured_groups": [
                    "w "
                ]
            },
            {
                "description": "Match, with a postfix and a literal space, capture the first token.",
                "pattern": "(\\w+) 1",
                "log": "Wazuh 123",
                "end_match": "123",
                "captured_groups": [
                    "Wazuh"
                ]
            },
            {
                "description": "Match, with a postfix and a literal space, capture the first token and the space..",
                "pattern": "^\\w+\\s$",
                "log": "w ",
                "end_match": " ",
                "captured_groups": []
            },
            {
                "description": "Match all with flags.",
                "pattern": "^\\w+\\s$",
                "log": "Wazuh ",
                "end_match": " ",
                "captured_groups": []
            },
            {
                "description": "Match all with flags and capture the first token",
                "pattern": "^(\\w+)\\s$",
                "log": "w ",
                "end_match": " ",
                "captured_groups": [
                    "w"
                ]
            },
            {
                "description": "Match and capture all with flags.",
                "pattern": "^(\\w+\\s)$",
                "log": "w ",
                "end_match": " ",
                "captured_groups": [
                    "w "
                ]
            },
            {
                "description": "Match all with backslashed token and flags.",
                "pattern": "^(\\w+)\\s$",
                "log": "Wazuh ",
                "end_match": " ",
                "captured_groups": [
                    "Wazuh"
                ]
            },
            {
                "description": "Match minimum log with flags.",
                "pattern": "^\\w+ $",
                "log": "w ",
                "end_match": " ",
                "captured_groups": []
            },
            {
                "description": "Match all with flags.",
                "pattern": "^\\w+ $",
                "log": "Wazuh ",
                "end_match": " ",
                "captured_groups": []
            },
            {
                "description": "Match minimum log with flags and capture the first token.",
                "pattern": "^(\\w+) $",
                "log": "w ",
                "end_match": " ",
                "captured_groups": [
                    "w"
                ]
            },
            {
                "description": "Match minimum log with flags and capture all.",
                "pattern": "^(\\w+ )$",
                "log": "w ",
                "end_match": " ",
                "captured_groups": [
                    "w "
                ]
            },
            {
                "description": "Match minimum log with flags and capture the first token.",
                "pattern": "^(\\w+) $",
                "log": "Wazuh ",
                "end_match": " ",
                "captured_groups": [
                    "Wazuh"
                ]
            },
            {
                "description": "Fail match becouse of flags.",
                "pattern": "^\\w+ $",
                "log": "Wazuh -",
                "end_match": null,
                "captured_groups": []
            },
            {
                "description": "Fail match becouse of flags.",
                "pattern": "^(\\w+ )$",
                "log": "Wazuh -",
                "end_match": null,
                "captured_groups": []
            }
        ]
    },
    {
        "description": "[Functionality] Lazy-Greedy behavior duality: Regex composed by a backslashed token with a '+' quantifier followed by a token that has no quantifier, where the last token does include the charmap of the first one.",
        "batch_test": [
            {
                "description": "Minimun log to match all, with backslashed token.",
                "pattern": "\\d+\\d",
                "log": "5",
                "end_match": null,
                "captured_groups": []
            },
            {
                "description": "Match all, with backslashed token.",
                "pattern": "(\\d+)\\d",
                "log": "5",
                "end_match": null,
                "captured_groups": []
            },
            {
                "description": "Minimun log to match all with capture group, with backslashed token.",
                "pattern": "(\\d+)\\w",
                "log": "12",
                "end_match": "2",
                "captured_groups": [
                    "1"
                ]
            },
            {
                "description": "Minimun log to match and capture all, with backslashed token.",
                "pattern": "\\d+(\\w)",
                "log": "12",
                "end_match": "2",
                "captured_groups": [
                    "2"
                ]
            },
            {
                "description": "Match all, with backslashed token.",
                "pattern": "\\d+\\w",
                "log": "12345",
                "end_match": "2345",
                "captured_groups": []
            },
            {
                "description": "Match all, capture the first token, with backslashed token.",
                "pattern": "(\\d+)\\w",
                "log": "12345",
                "end_match": "2345",
                "captured_groups": [
                    "1"
                ]
            },
            {
                "description": "Match all, capture the second token, with backslashed token.",
                "pattern": "\\d+(\\w)",
                "log": "12345",
                "end_match": "2345",
                "captured_groups": [
                    "2"
                ]
            },
            {
                "description": "No match, no item to consume.",
                "pattern": "^\\d+\\d",
                "log": "5",
                "end_match": null,
                "captured_groups": []
            },
            {
                "description": "No match, no item to consume.",
                "pattern": "^(\\d+)\\d",
                "log": "5",
                "end_match": null,
                "captured_groups": []
            },
            {
                "description": "Match all, capture the first token with flags.",
                "pattern": "^(\\d+)\\w$",
                "log": "12",
                "end_match": "2",
                "captured_groups": [
                    "1"
                ]
            },
            {
                "description": "Match all, capture the second token with flags.",
                "pattern": "^\\d+(\\w)$",
                "log": "12",
                "end_match": "2",
                "captured_groups": [
                    "2"
                ]
            },
            {
                "description": "Match all with flags.",
                "pattern": "^\\d+\\w$",
                "log": "12345",
                "end_match": "5",
                "captured_groups": []
            },
            {
                "description": "Match all with flags.",
                "pattern": "^(\\d+)\\w$",
                "log": "12345",
                "end_match": "5",
                "captured_groups": [
                    "1234"
                ]
            },
            {
                "description": "Match all with flags and capture the second token.",
                "pattern": "^\\d+(\\w)$",
                "log": "12345",
                "end_match": "5",
                "captured_groups": [
                    "5"
                ]
            },
            {
                "description": "Dont match with flags.",
                "pattern": "^\\d+(\\w)$",
                "log": "12345&&&&&&&",
                "end_match": null,
                "captured_groups": []
            }
        ]
    },
    {
        "description": "[Functionality] Lazy-Greedy behavior duality: Regex composed by a backslashed token with a '+' quantifier followed by a token that has the '+' quantifier, where the last token does not include the charmap of the first one.",
        "batch_test": [
            {
                "description": "Minimun log to match all.",
                "pattern": "\\w+\\s+",
                "log": "w ",
                "end_match": " ",
                "captured_groups": []
            },
            {
                "description": "Minimun log to match all, with capture all.",
                "pattern": "(\\w+\\s+)",
                "log": "w ",
                "end_match": " ",
                "captured_groups": [
                    "w "
                ]
            },
            {
                "description": "Minimun log to match all, capture the first token.",
                "pattern": "(\\w+)\\s+",
                "log": "w ",
                "end_match": " ",
                "captured_groups": [
                    "w"
                ]
            },
            {
                "description": "Minimun log to match all, capture the second token.",
                "pattern": "\\w+(\\s+)",
                "log": "w ",
                "end_match": " ",
                "captured_groups": [
                    " "
                ]
            },
            {
                "description": "Match all.",
                "pattern": "\\w+\\s+",
                "log": "Wazuh ",
                "end_match": " ",
                "captured_groups": []
            },
            {
                "description": "Match all with group.",
                "pattern": "(\\w+)\\s+",
                "log": "Wazuh ",
                "end_match": " ",
                "captured_groups": [
                    "Wazuh"
                ]
            },
            {
                "description": "Match all with consecutive group.",
                "__known_issue": "It should match but does not, adjacent capture groups are not supported. BUG 1 of issue: https://github.com/wazuh/wazuh/issues/14420",
                "ignore_result": true,
                "pattern": "(\\w+)(\\s+)",
                "log": "Wazuh ",
                "end_match": " ",
                "captured_groups": [
                    "Wazuh",
                    " "
                ]
            },
            {
                "description": "Match all with no consecutive group and opcional.",
                "pattern": "(\\w+)\\d*(\\s+)",
                "log": "Wazuh ",
                "end_match": " ",
                "captured_groups": [
                    "Wazuh",
                    " "
                ]
            },
            {
                "description": "Match all with no consecutive group and opcional",
                "pattern": "(\\w+)\\d*(\\s+)",
                "log": "Wazuh123 ",
                "end_match": " ",
                "captured_groups": [
                    "Wazuh",
                    " "
                ]
            },
            {
                "description": "Match all with no consecutive group.",
                "pattern": "(\\w+)\\d+(\\s+)",
                "log": "Wazuh123 ",
                "end_match": " ",
                "captured_groups": [
                    "Wazuh",
                    " "
                ]
            },
            {
                "description": "Match all with literal at the end.",
                "pattern": "\\w+\\s+1",
                "log": "Wazuh 1",
                "end_match": "1",
                "captured_groups": []
            },
            {
                "description": "Match all, 1 character with literal at the end and capture the first token.",
                "pattern": "(\\w+)\\s+1",
                "log": "w 1",
                "end_match": "1",
                "captured_groups": [
                    "w"
                ]
            },
            {
                "description": "Match all, 1 character with literal at the end and no capture the literal.",
                "pattern": "(\\w+\\s+)1",
                "log": "w 1",
                "end_match": "1",
                "captured_groups": [
                    "w "
                ]
            },
            {
                "description": "Match all with literal at the end and capture the first token.",
                "pattern": " (\\w+)\\s+1",
                "log": " Wazuh 1",
                "end_match": "1",
                "captured_groups": [
                    "Wazuh"
                ]
            },
            {
                "description": "Minimun log to match all, with flags.",
                "pattern": "^\\w+\\s+$",
                "log": "w ",
                "end_match": " ",
                "captured_groups": []
            },
            {
                "description": "Match all, with flags.",
                "ignore_result": true,
                "__know_issue": "Err retval.",
                "pattern": "^\\w+\\s+$",
                "log": "Wazuh  ",
                "end_match": " ",
                "captured_groups": []
            },
            {
                "description": "Minimun log to match all, with flags and capture the first token.",
                "pattern": "^(\\w+)\\s+$",
                "log": "w ",
                "end_match": " ",
                "captured_groups": [
                    "w"
                ]
            },
            {
                "description": "Minimun log to match all, with flags and capture the second token.",
                "pattern": "^\\w+(\\s+)$",
                "log": "w ",
                "end_match": " ",
                "captured_groups": [
                    " "
                ]
            },
            {
                "description": "Minimun log to match all, with flags and capture all.",
                "pattern": "^(\\w+\\s+)$",
                "log": "w ",
                "end_match": " ",
                "captured_groups": [
                    "w "
                ]
            },
            {
                "description": "Dont match.",
                "pattern": "^\\w+\\s+$",
                "log": "Wazuh -",
                "end_match": null,
                "captured_groups": []
            },
            {
                "description": "Dont match.",
                "pattern": "^(\\w+\\s+)$",
                "log": "Wazuh -",
                "end_match": null,
                "captured_groups": []
            }
        ]
    },
    {
        "description": "[Functionality] Lazy-Greedy behavior duality: Regex composed by a backslashed token with a '+' quantifier followed by a token that has the '*' quantifier, where the last token does include the charmap of the first one.",
        "batch_test": [
            {
                "description": "Minimun log to match all.",
                "pattern": "\\w+\\s*",
                "log": "w",
                "end_match": "w",
                "captured_groups": []
            },
            {
                "description": "Minimun log to match all and patter with a optional token.",
                "pattern": "\\w+\\s*",
                "__known_issue": "Matches but if the regex ends with a token with the quantifier '+' or '*', then it does not return the pointer to the last character matched, as it should be. BUG 3 of issue: https://github.com/wazuh/wazuh/issues/14420",
                "ignore_result": true,
                "log": "w ",
                "end_match": " ",
                "captured_groups": []
            },
            {
                "description": "Minimun log to match all and capture all.",
                "pattern": "(\\w+\\s*)",
                "__known_issue": "Matches but if the regex ends with a token with the quantifier '+' or '*', then it does not return the pointer to the last character matched, as it should be. BUG 3 of issue: https://github.com/wazuh/wazuh/issues/14420",
                "ignore_result": true,
                "log": "w",
                "end_match": "w",
                "captured_groups": [
                    "w"
                ]
            },
            {
                "description": "Match all and capture all.",
                "pattern": "(\\w+\\s*)",
                "__known_issue": "Matches but if the regex ends with a token with the quantifier '+' or '*', then it does not return the pointer to the last character matched, as it should be. BUG 3 of issue: https://github.com/wazuh/wazuh/issues/14420",
                "ignore_result": true,
                "debug": false,
                "log": "Wazuh",
                "end_match": "h",
                "captured_groups": [
                    "Wazuh"
                ]
            },
            {
                "description": "Minimun log with optional token to match and capture all.",
                "ignore_result": true,
                "__known_issue": "Matches but if the regex ends with a token with the quantifier '+' or '*', then it does not return the pointer to the last character matched, as it should be. BUG 3 of issue: https://github.com/wazuh/wazuh/issues/14420",
                "pattern": "(\\w+\\s*)",
                "log": "w ",
                "end_match": " ",
                "captured_groups": [
                    "w "
                ]
            },
            {
                "description": "Minimun log to match and capture the first token.",
                "pattern": "(\\w+)\\s*",
                "log": "w",
                "end_match": "w",
                "captured_groups": [
                    "w"
                ]
            },
            {
                "description": "inimun log with optional token to match and capture the first token.",
                "ignore_result": true,
                "__known_issue": "Matches but if the regex ends with a token with the quantifier '+' or '*', then it does not return the pointer to the last character matched, as it should be. BUG 3 of issue: https://github.com/wazuh/wazuh/issues/14420",
                "pattern": "(\\w+)\\s*",
                "log": "w ",
                "end_match": " ",
                "captured_groups": [
                    "w"
                ]
            },
            {
                "description": "Match all.",
                "pattern": "\\w+\\s*",
                "ignore_result": true,
                "__known_issue": "Matches but if the regex ends with a token with the quantifier '+' or '*', then it does not return the pointer to the last character matched, as it should be. BUG 3 of issue: https://github.com/wazuh/wazuh/issues/14420",
                "log": "Wazuh ",
                "end_match": " ",
                "captured_groups": []
            },
            {
                "description": "Match all, capture all.",
                "ignore_result": true,
                "__known_issue": "Matches but if the regex ends with a token with the quantifier '+' or '*', then it does not return the pointer to the last character matched, as it should be. BUG 3 of issue: https://github.com/wazuh/wazuh/issues/14420",
                "pattern": "(\\w+\\s*)",
                "log": "Wazuh ",
                "end_match": " ",
                "captured_groups": [
                    "Wazuh "
                ]
            },
            {
                "description": "Match all with no consecutive group.",
                "__known_issue": "It should match but does not, adjacent capture groups are not supported. BUG 1 of issue: https://github.com/wazuh/wazuh/issues/14420",
                "ignore_result": true,
                "pattern": "(\\w+)(\\s*)",
                "log": "Wazuh ",
                "end_match": " ",
                "captured_groups": [
                    "Wazuh",
                    " "
                ]
            },
            {
                "description": "Match all with no consecutive group and opcional.",
                "pattern": "(\\w+)\\d+(\\s*)",
                "ignore_result": true,
                "__known_issue": "Matches but if the regex ends with a token with the quantifier '+' or '*', then it does not return the pointer to the last character matched, as it should be. BUG 3 of issue: https://github.com/wazuh/wazuh/issues/14420",
                "log": "Wazuh ",
                "end_match": null,
                "captured_groups": []
            },
            {
                "description": "Match all with no consecutive group and opcional.",
                "pattern": "(\\w+)\\d+(\\s*)",
                "ignore_result": true,
                "__known_issue": "Matches but if the regex ends with a token with the quantifier '+' or '*', then it does not return the pointer to the last character matched, as it should be. BUG 3 of issue: https://github.com/wazuh/wazuh/issues/14420",
                "log": "Wazuh123 ",
                "end_match": " ",
                "captured_groups": [
                    "Wazuh",
                    " "
                ]
            },
            {
                "description": "Match all with no consecutive group and opcional.",
                "pattern": "(\\w+)\\d*(\\s*)",
                "ignore_result": true,
                "__known_issue": "Matches but if the regex ends with a token with the quantifier '+' or '*', then it does not return the pointer to the last character matched, as it should be. BUG 3 of issue: https://github.com/wazuh/wazuh/issues/14420",
                "debug": false,
                "log": "Wazuh123 ",
                "end_match": " ",
                "captured_groups": [
                    "Wazuh",
                    " "
                ]
            },
            {
                "description": "Match all with literal at the end.",
                "pattern": "\\w+\\s*1",
                "log": "Wazuh 1",
                "end_match": "1",
                "captured_groups": []
            },
            {
                "description": "Match all with literal at the end, 1 character and capture the first token.",
                "pattern": "(\\w+)\\s*1",
                "log": "w 1",
                "end_match": "1",
                "captured_groups": [
                    "w"
                ]
            },
            {
                "description": "Match all with literal at the end, 1 character and capture the first token and te optional.",
                "pattern": "(\\w+\\s*)1",
                "log": "w 1",
                "end_match": "1",
                "captured_groups": [
                    "w "
                ]
            },
            {
                "description": "Match all with literal at the end and capture the first token.",
                "pattern": " (\\w+)\\s*1",
                "log": " Wazuh 1",
                "end_match": "1",
                "captured_groups": [
                    "Wazuh"
                ]
            },
            {
                "description": "Minimun log to match all, with flags.",
                "pattern": "^\\w+\\s*$",
                "ignore_result": true,
                "__known_issue": "It should match but does not, adjacent capture groups are not supported. BUG 1 of issue: https://github.com/wazuh/wazuh/issues/14420",
                "log": "w ",
                "end_match": " ",
                "captured_groups": []
            },
            {
                "description": "Match all, with flags.",
                "ignore_result": true,
                "__known_issue": "It should match but does not, adjacent capture groups are not supported. BUG 1 of issue: https://github.com/wazuh/wazuh/issues/14420",
                "pattern": "^\\w+\\s*$",
                "log": "Wazuh  ",
                "end_match": " ",
                "captured_groups": []
            },
            {
                "description": "Minimun log to match all, with flags and capture the first token.",
                "pattern": "^(\\w+)\\s*$",
                "ignore_result": true,
                "__known_issue": "It should match but does not, adjacent capture groups are not supported. BUG 1 of issue: https://github.com/wazuh/wazuh/issues/14420",
                "log": "w ",
                "end_match": " ",
                "captured_groups": [
                    "w"
                ]
            },
            {
                "description": "Minimun log to match all, with flags and capture the first token.",
                "pattern": "^(\\w+)\\s*$",
                "ignore_result": true,
                "__known_issue": "It should match but does not, adjacent capture groups are not supported. BUG 1 of issue: https://github.com/wazuh/wazuh/issues/14420",
                "log": "w ",
                "end_match": " ",
                "captured_groups": [
                    "w"
                ]
            },
            {
                "description": "Minimun log to match all, with flags and capture all.",
                "pattern": "^(\\w+\\s*)$",
                "ignore_result": true,
                "__known_issue": "It should match but does not, adjacent capture groups are not supported. BUG 1 of issue: https://github.com/wazuh/wazuh/issues/14420",
                "log": "w ",
                "end_match": " ",
                "captured_groups": [
                    "w "
                ]
            },
            {
                "description": "Dont match.",
                "pattern": "^\\w+\\s*$",
                "log": "Wazuh -",
                "end_match": null,
                "captured_groups": []
            },
            {
                "description": "Dont match.",
                "pattern": "^(\\w+\\s*)$",
                "log": "Wazuh -",
                "end_match": null,
                "captured_groups": []
            }
        ]
    },
    {
        "description": "[Functionality] Lazy-Greedy behavior duality: Regex composed by backslashed tokens with '*' quantifiers. Test the 'st_error', 'pt_error[]' and 'pt_error_str[]' for parcial matches and rewind.",
        "batch_test": [
            {
                "description": "Saves and restores the first position error.",
                "pattern": "\\w+_1 \\w+_2 \\w+_3 \\w+_4 \\w+_5 \\w+_6",
                "log": "wa_11 wa_1 wa_2 wa_3 wa_4 wa_5 wa_6",
                "end_match": "6",
                "captured_groups": []
            },
            {
                "description": "Saves and restores the second position error.",
                "pattern": "\\w+_1 \\w+_2 \\w+_3 \\w+_4 \\w+_5 \\w+_6",
                "log": "wa_1 wa_22 wa_1 wa_2 wa_3 wa_4 wa_5 wa_6",
                "end_match": "6",
                "captured_groups": []
            },
            {
                "description": "Saves and restores the third position error.",
                "pattern": "\\w+_1 \\w+_2 \\w+_3 \\w+_4 \\w+_5 \\w+_6",
                "log": "wa_1 wa_2 wa_1 wa_2 wa_3 wa_4 wa_5 wa_6",
                "end_match": "6",
                "captured_groups": []
            },
            {
                "description": "Saves and restores the fourth position error.",
                "pattern": "\\w+_1 \\w+_2 \\w+_3 \\w+_4 \\w+_5 \\w+_6",
                "log": "wa_1 wa_2 wa_3 wa_1 wa_2 wa_3 wa_4 wa_5 wa_6",
                "end_match": "6",
                "captured_groups": []
            },
            {
                "description": "Saves and restores the fifth position error.",
                "pattern": "\\w+_1 \\w+_2 \\w+_3 \\w+_4 \\w+_5 \\w+_6",
                "log": "wa_1 wa_2 wa_3 wa_4 wa_1 wa_2 wa_3 wa_4 wa_5 wa_6",
                "end_match": "6",
                "captured_groups": []
            },
            {
                "description": "Saves and restores the sixth position error.",
                "pattern": "\\w+_1 \\w+_2 \\w+_3 \\w+_4 \\w+_5 \\w+_6",
                "log": "wa_1 wa_2 wa_3 wa_4 wa_5 wa_1 wa_2 wa_3 wa_4 wa_5 wa_6",
                "end_match": "6",
                "captured_groups": []
            },
            {
                "description": "Saves and restores the first position error. But the first should match with the next character.",
                "pattern": "\\w+1 \\w+2 \\w+3 \\w+4 \\w+5 \\w+6",
                "log": "z1x1 x2 x3 x4 x5 x6",
                "end_match": "6",
                "captured_groups": []
            },
            {
                "description": "Saves and restores the second position error. But the second should match with the next character.",
                "pattern": "\\w+1 \\w+2 \\w+3 \\w+4 \\w+5 \\w+6",
                "log": "z1 x2x2 x3 x4 x5 x6",
                "end_match": "6",
                "captured_groups": []
            },
            {
                "description": "Saves and restores the third position error. But the third should match with the next character.",
                "pattern": "\\w+1 \\w+2 \\w+3 \\w+4 \\w+5 \\w+6",
                "log": "z1 x2x2 x3 x4 x5 x6",
                "end_match": "6",
                "captured_groups": []
            },
            {
                "description": "Saves and restores the fourth position error. But the fourth should match with the next character.",
                "pattern": "\\w+1 \\w+2 \\w+3 \\w+4 \\w+5 \\w+6",
                "log": "z1 x2 x3 x4x4 x5 x6",
                "end_match": "6",
                "captured_groups": []
            },
            {
                "description": "Saves and restores the fifth position error. But the fifth should match with the next character.",
                "pattern": "\\w+1 \\w+2 \\w+3 \\w+4 \\w+5 \\w+6",
                "ignore_result": true,
                "__known_issue": "It should match but does not, as the states stack is limited to 4 states. BUG 6 of issue: https://github.com/wazuh/wazuh/issues/14420",
                "log": "z1 x2 x3 x4 x5x5 x6",
                "end_match": "6",
                "captured_groups": []
            },
            {
                "description": "Saves and restores the sixth position error. But the sixth should match with the next character.",
                "pattern": "\\w+1 \\w+2 \\w+3 \\w+4 \\w+5 \\w+6",
                "log": "z1 x2 x3 x4 x5 x6x6",
                "ignore_result": true,
                "__known_issue": "It should match but does not, as the states stack is limited to 4 states. BUG 6 of issue: https://github.com/wazuh/wazuh/issues/14420",
                "end_match": "6",
                "captured_groups": []
            }
        ]
    },
    {
        "description": "[Functionality] Only backslashed tokens with the '*' quantifier.",
        "batch_test": [
            {
                "description": "Match all.",
                "__known_issue": "Matches but if the regex ends with a token with the quantifier '+' or '*', then it does not return the pointer to the last character matched, as it should be. BUG 3 of issue: https://github.com/wazuh/wazuh/issues/14420",
                "ignore_result": true,
                "pattern": "\\w*",
                "log": "Wazuh",
                "end_match": "h",
                "captured_groups": []
            },
            {
                "description": "Match 0-0",
                "__known_issue": "When the regex consists only of tokens with '*' quantifiers, then it always matches. When it matches having 0 matching characters, then it returns the pointer poiting to one byte before the beginning of the string. BUG 4 Issue: https://github.com/Wazuh/Wazuh/issues/14249",
                "skip_test": true,
                "pattern": "\\d*",
                "log": "Wazuh",
                "end_match": "Wazuh",
                "captured_groups": []
            },
            {
                "description": "Mach all with capture group.",
                "ignore_result": true,
                "pattern": "(\\w*)",
                "log": "Wazuh",
                "end_match": "h",
                "captured_groups": [
                    "Wazuh"
                ]
            },
            {
                "description": "Match 0-0, with capture group",
                "__known_issue": "When the regex consists only of tokens with '*' quantifiers, then it always matches. When it matches having 0 matching characters, then it returns the pointer poiting to one byte before the beginning of the string. BUG Issue: https://github.com/Wazuh/Wazuh/issues/14249",
                "skip_test": true,
                "pattern": "(\\d*)",
                "log": "Wazuh",
                "end_match": "Wazuh",
                "captured_groups": [
                    ""
                ]
            },
            {
                "description": "Mach all with capture group and flags.",
                "__known_issue": "Matches but if the regex ends with a token with the quantifier '+' or '*', then it does not return the pointer to the last character matched, as it should be. BUG 3 of issue: https://github.com/wazuh/wazuh/issues/14420",
                "ignore_result": true,
                "debug": false,
                "pattern": "^\\w*$",
                "log": "Wazuh",
                "end_match": "h",
                "captured_groups": []
            },
            {
                "description": "With capture group, match all (And flags)",
                "__known_issue": "Matches but if the regex ends with a token with the quantifier '+' or '*', then it does not return the pointer to the last character matched, as it should be. BUG 3 of issue: https://github.com/wazuh/wazuh/issues/14420",
                "ignore_result": true,
                "pattern": "^(\\w*)$",
                "log": "Wazuh",
                "end_match": "h",
                "captured_groups": [
                    "Wazuh"
                ]
            },
            {
                "description": "Parcial match and fail, with flags.",
                "pattern": "^\\w*$",
                "log": "Wazuh ",
                "end_match": null,
                "captured_groups": []
            },
            {
                "description": "Parcial match and fail, with flags and capture group.",
                "pattern": "^(\\w*)$",
                "log": "Wazuh ",
                "end_match": null,
                "captured_groups": []
            },
            {
                "description": "Match one character.",
                "pattern": "\\w*",
                "log": "w",
                "end_match": "w",
                "captured_groups": []
            },
            {
                "description": "Match one character with capture group.",
                "pattern": "(\\w*)",
                "log": "w",
                "end_match": "w",
                "captured_groups": [
                    "w"
                ]
            },
            {
                "description": "Match one character and flags.",
                "pattern": "^\\w*$",
                "log": "w",
                "end_match": "w",
                "captured_groups": []
            },
            {
                "description": "Match one character, with group and flags.",
                "pattern": "^(\\w*)$",
                "log": "w",
                "end_match": "w",
                "captured_groups": [
                    "w"
                ]
            },
            {
                "description": "Match 0-0 with flags.",
                "debug": true,
                "pattern": "^\\w*$",
                "log": "",
                "end_match": "",
                "captured_groups": []
            },
            {
                "description": "Match 0-0 and capture all",
                "__known_issue": "If the pattern has only one token that has the quantifier '*' and it is inside a capture group, when the log is empty, it matches correctly, returning the pointer to the end of the string but does not capture the empty group as expected. BUG 5 of issue: https://github.com/wazuh/wazuh/issues/14420",
                "ignore_result": true,
                "pattern": "(\\w*)",
                "log": "",
                "end_match": "",
                "captured_groups": [
                    ""
                ]
            },
            {
                "description": "Match 0-0 with flags and capture all",
                "__known_issue": "If the pattern has only one token that has the quantifier '*' and it is inside a capture group, when the log is empty, it matches correctly, returning the pointer to the end of the string but does not capture the empty group as expected. BUG 5 of issue: https://github.com/wazuh/wazuh/issues/14420",
                "ignore_result": true,
                "pattern": "^(\\w*)$",
                "log": "",
                "end_match": "",
                "captured_groups": [
                    ""
                ]
            }
        ]
    },
    {
        "description": "[Functionality] Lazy-Greedy behavior duality: Regex composed by a backslashed token with a '*' quantifier followed by a token that has no quantifier, where the last token does not include the charmap of the first one.er.",
        "batch_test": [
            {
                "description": "Match 1 character.",
                "pattern": "\\w*\\s",
                "log": "w ",
                "end_match": " ",
                "captured_groups": []
            },
            {
                "description": "Match all.",
                "pattern": "\\w*\\s",
                "log": "Wazuh ",
                "end_match": " ",
                "captured_groups": []
            },
            {
                "description": "Match 1 character with capture group.",
                "pattern": "(\\w*)\\s",
                "log": "w ",
                "end_match": " ",
                "captured_groups": [
                    "w"
                ]
            },
            {
                "description": "Minimun log to match all, with backslashed token and capture group",
                "pattern": "(\\w*)\\s",
                "log": " ",
                "end_match": " ",
                "captured_groups": [
                    ""
                ]
            },
            {
                "description": "Match all, with backslashed token and capture all",
                "pattern": "(\\w*\\s)",
                "log": "w ",
                "end_match": " ",
                "captured_groups": [
                    "w "
                ]
            },
            {
                "description": "Minimun log to match all, with backslashed token and capture all.",
                "pattern": "(\\w*\\s)",
                "log": " ",
                "end_match": " ",
                "captured_groups": [
                    " "
                ]
            },
            {
                "description": "Mtch all, with backslashed token and capture the first token.",
                "pattern": "(\\w*)\\s",
                "log": "Wazuh ",
                "end_match": " ",
                "captured_groups": [
                    "Wazuh"
                ]
            },
            {
                "description": "Minimun log to match all, with literal token.",
                "pattern": "\\w* ",
                "log": " ",
                "end_match": " ",
                "captured_groups": []
            },
            {
                "description": "Match all, with 1 character and literal token.",
                "pattern": "\\w* ",
                "log": "w ",
                "end_match": " ",
                "captured_groups": []
            },
            {
                "description": "Match all with literal.",
                "pattern": "\\w* ",
                "log": "Wazuh ",
                "end_match": " ",
                "captured_groups": []
            },
            {
                "description": "Match all, with literal token and capture the first token.",
                "pattern": "(\\w*) ",
                "log": "w ",
                "end_match": " ",
                "captured_groups": [
                    "w"
                ]
            },
            {
                "description": "Match all, with literal token and capture all.",
                "pattern": "(\\w* )",
                "log": "w ",
                "end_match": " ",
                "captured_groups": [
                    "w "
                ]
            },
            {
                "description": "Match all, with literal token and capture the first token.",
                "pattern": "(\\w*) ",
                "log": "Wazuh ",
                "end_match": " ",
                "captured_groups": [
                    "Wazuh"
                ]
            },
            {
                "description": "Match all, with literal token.",
                "pattern": "\\w*\\s1",
                "log": "Wazuh 1",
                "end_match": "1",
                "captured_groups": []
            },
            {
                "description": "Match all, with backlashed token and capture the first token.",
                "pattern": "(\\w*)\\s1",
                "log": "w 1",
                "end_match": "1",
                "captured_groups": [
                    "w"
                ]
            },
            {
                "description": "Match all, with backlashed token and capture the first token.",
                "pattern": "(\\w*\\s)1",
                "log": "w 1",
                "end_match": "1",
                "captured_groups": [
                    "w "
                ]
            },
            {
                "description": "Match all, with backlashed token and capture the first token.",
                "pattern": "(\\w*)\\s1",
                "log": "Wazuh 1",
                "end_match": "1",
                "captured_groups": [
                    "Wazuh"
                ]
            },
            {
                "description": "Match, with backlashed token and literal.",
                "pattern": "\\w*\\s1",
                "log": "w 123",
                "end_match": "123",
                "captured_groups": []
            },
            {
                "description": "Match, with liteals token.",
                "pattern": "\\w* 1",
                "log": "Wazuh 123",
                "end_match": "123",
                "captured_groups": []
            },
            {
                "description": "Match, with liteals token and capture the first.",
                "pattern": "(\\w*) 1",
                "log": "w 123",
                "end_match": "123",
                "captured_groups": [
                    "w"
                ]
            },
            {
                "description": "Match, with liteals token and capture the first token and literal.",
                "pattern": "(\\w* )1",
                "log": "w 123",
                "end_match": "123",
                "captured_groups": [
                    "w "
                ]
            },
            {
                "description": "Match, with liteals token and capture the first token.",
                "pattern": "(\\w*) 1",
                "log": "Wazuh 123",
                "end_match": "123",
                "captured_groups": [
                    "Wazuh"
                ]
            },
            {
                "description": "Match all with backlashed token and flags.",
                "pattern": "^\\w*\\s$",
                "log": "w ",
                "end_match": " ",
                "captured_groups": []
            },
            {
                "description": "Match all with backlashed token and flags.",
                "pattern": "^\\w*\\s$",
                "log": "Wazuh ",
                "end_match": " ",
                "captured_groups": []
            },
            {
                "description": "Match all with backlashed token, flags and capture the first group.",
                "pattern": "^(\\w*)\\s$",
                "log": "w ",
                "end_match": " ",
                "captured_groups": [
                    "w"
                ]
            },
            {
                "description": "Match all with backlashed token, flags and capture all.",
                "pattern": "^(\\w*\\s)$",
                "log": "w ",
                "end_match": " ",
                "captured_groups": [
                    "w "
                ]
            },
            {
                "description": "Match all with backlashed token and flags.",
                "pattern": "^(\\w*)\\s$",
                "log": "Wazuh ",
                "end_match": " ",
                "captured_groups": [
                    "Wazuh"
                ]
            },
            {
                "description": "Match all with liteal token and flags.",
                "pattern": "^\\w* $",
                "log": "w ",
                "end_match": " ",
                "captured_groups": []
            },
            {
                "description": "Match all with literal token and flags.",
                "pattern": "^\\w* $",
                "log": "Wazuh ",
                "end_match": " ",
                "captured_groups": []
            },
            {
                "description": "Match all with literal token, flags and capture the first.",
                "pattern": "^(\\w*) $",
                "log": "w ",
                "end_match": " ",
                "captured_groups": [
                    "w"
                ]
            },
            {
                "description": "Match all with literal token and flags.",
                "pattern": "^(\\w* )$",
                "log": "w ",
                "end_match": " ",
                "captured_groups": [
                    "w "
                ]
            },
            {
                "pattern": "^(\\w*) $",
                "log": "Wazuh ",
                "end_match": " ",
                "captured_groups": [
                    "Wazuh"
                ]
            },
            {
                "pattern": "^\\w* $",
                "log": "Wazuh -",
                "end_match": null,
                "captured_groups": []
            },
            {
                "pattern": "^(\\w* )$",
                "log": "Wazuh -",
                "end_match": null,
                "captured_groups": []
            }
        ]
    },
    {
        "description": "[Functionality] Lazy-Greedy behavior duality: Regex composed by a backslashed token with a '*' quantifier followed by a token that has no quantifier, where the last token does include the charmap of the first one.",
        "batch_test": [
            {
                "description": "Match all. 0-0 and backlashed token.",
                "pattern": "\\d*\\w",
                "log": "5",
                "end_match": "5",
                "captured_groups": []
            },
            {
                "description": "Match all. 0-0 and backlashed token and capture group.",
                "pattern": "(\\d*)\\w",
                "log": "5",
                "end_match": "5",
                "captured_groups": [
                    ""
                ]
            },
            {
                "description": "\\w matches with '1' character",
                "pattern": "\\d*\\w",
                "log": "12",
                "end_match": "12",
                "captured_groups": []
            },
            {
                "description": "\\w matches with '1' character",
                "pattern": "(\\d*)\\w",
                "log": "12",
                "end_match": "12",
                "captured_groups": [
                    ""
                ]
            },
            {
                "description": "Matches and capture group.",
                "pattern": "\\d*(\\w)",
                "log": "12",
                "end_match": "12",
                "captured_groups": [
                    "1"
                ]
            },
            {
                "description": "Matches with nothing (0-0) and \\w matches to the first number.",
                "pattern": "\\d*\\w",
                "log": "12345",
                "end_match": "12345",
                "captured_groups": []
            },
            {
                "description": "Matches with nothing (0-0) and \\w matches to the first number.",
                "pattern": "(\\d*)\\w",
                "log": "12345",
                "end_match": "12345",
                "captured_groups": [
                    ""
                ]
            },
            {
                "description": "Matches with nothing (0-0) and \\w matches to the first number.",
                "pattern": "\\d*(\\w)",
                "log": "12345",
                "end_match": "12345",
                "captured_groups": [
                    "1"
                ]
            },
            {
                "description": "Matches with nothing (0-0) and \\d matches to the first number.",
                "pattern": "^\\d*\\d",
                "log": "5",
                "end_match": "5",
                "captured_groups": []
            },
            {
                "description": "Matches with nothing (0-0) and \\d matches to the first number.",
                "pattern": "^(\\d*)\\d",
                "log": "5",
                "end_match": "5",
                "captured_groups": [
                    ""
                ]
            },
            {
                "pattern": "^(\\d*)\\w$",
                "log": "12",
                "end_match": "2",
                "captured_groups": [
                    "1"
                ]
            },
            {
                "pattern": "^\\d*(\\w)$",
                "log": "12",
                "end_match": "2",
                "captured_groups": [
                    "2"
                ]
            },
            {
                "description": "Matches with nothing (0-0) and \\d matches to the last number.",
                "pattern": "^\\d*\\w$",
                "log": "12345",
                "end_match": "5",
                "captured_groups": []
            },
            {
                "description": "Matches with nothing (0-0) and \\d matches to the last number.",
                "pattern": "^(\\d*)\\w$",
                "log": "12345",
                "end_match": "5",
                "captured_groups": [
                    "1234"
                ]
            },
            {
                "description": "Matches with nothing (0-0) and \\d matches to the last number.",
                "pattern": "^\\d*(\\w)$",
                "log": "12345",
                "end_match": "5",
                "captured_groups": [
                    "5"
                ]
            },
            {
                "description": "Dont match.",
                "pattern": "^\\d*(\\w)$",
                "log": "12345&&&&&&&",
                "end_match": null,
                "captured_groups": []
            }
        ]
    },
    {
        "description": "[Functionality] Lazy-Greedy behavior duality: Regex composed by a backslashed token with a '*' quantifier followed by a token that has the '+' quantifier, where the last token does not include the charmap of the first one.",
        "batch_test": [
            {
                "pattern": "\\w*\\s+",
                "log": "w ",
                "end_match": " ",
                "captured_groups": []
            },
            {
                "description": "Capture all.",
                "pattern": "(\\w*\\s+)",
                "log": "w ",
                "end_match": " ",
                "captured_groups": [
                    "w "
                ]
            },
            {
                "pattern": "(\\w*)\\s+",
                "log": "w ",
                "end_match": " ",
                "captured_groups": [
                    "w"
                ]
            },
            {
                "pattern": "\\w*\\s+",
                "log": "Wazuh ",
                "end_match": " ",
                "captured_groups": []
            },
            {
                "pattern": "(\\w*)\\s+",
                "log": "Wazuh ",
                "end_match": " ",
                "captured_groups": [
                    "Wazuh"
                ]
            },
            {
                "__known_issue": "It should match but does not, adjacent capture groups are not supported. BUG 1 of issue: https://github.com/wazuh/wazuh/issues/14420",
                "ignore_result": true,
                "pattern": "(\\w*)(\\s+)",
                "log": "Wazuh ",
                "end_match": " ",
                "captured_groups": [
                    "Wazuh",
                    " "
                ]
            },
            {
                "description": "2 no consecutive groups, and opcional.",
                "pattern": "(\\w*)\\d*(\\s+)",
                "log": "Wazuh ",
                "end_match": " ",
                "captured_groups": [
                    "Wazuh",
                    " "
                ]
            },
            {
                "description": "2 no consecutive groups, and opcional.",
                "pattern": "(\\w*)\\d*(\\s+)",
                "log": "Wazuh123 ",
                "end_match": " ",
                "captured_groups": [
                    "Wazuh",
                    " "
                ]
            },
            {
                "description": "2 groups no consecutive",
                "pattern": "(\\w*)\\d+(\\s+)",
                "log": "Wazuh123 ",
                "end_match": " ",
                "captured_groups": [
                    "Wazuh",
                    " "
                ]
            },
            {
                "description": "2 groups no consecutive, and opcional",
                "pattern": "(\\w*)\\d*(\\s*)",
                "__known_issue": "Matches but if the regex ends with a token with the quantifier '+' or '*', then it does not return the pointer to the last character matched, as it should be. BUG 3 of issue: https://github.com/wazuh/wazuh/issues/14420",
                "ignore_result": true,
                "log": "Wazuh ",
                "end_match": " ",
                "captured_groups": [
                    "Wazuh",
                    " "
                ]
            },
            {
                "description": "2 groups no consecutive, and opcional",
                "pattern": "(\\w*)\\d*(\\s*)",
                "__known_issue": "Matches but if the regex ends with a token with the quantifier '+' or '*', then it does not return the pointer to the last character matched, as it should be. BUG 3 of issue: https://github.com/wazuh/wazuh/issues/14420",
                "ignore_result": true,
                "log": "Wazuh123 ",
                "end_match": " ",
                "captured_groups": [
                    "Wazuh",
                    " "
                ]
            },
            {
                "description": "2 groups no consecutive",
                "pattern": "(\\w*)\\d+(\\s*)",
                "__known_issue": "Matches but if the regex ends with a token with the quantifier '+' or '*', then it does not return the pointer to the last character matched, as it should be. BUG 3 of issue: https://github.com/wazuh/wazuh/issues/14420",
                "ignore_result": true,
                "log": "Wazuh123 ",
                "end_match": " ",
                "captured_groups": [
                    "Wazuh",
                    " "
                ]
            },
            {
                "pattern": "\\w*\\s+1",
                "log": "Wazuh 1",
                "end_match": "1",
                "captured_groups": []
            },
            {
                "pattern": "(\\w*)\\s+1",
                "log": "w 1",
                "end_match": "1",
                "captured_groups": [
                    "w"
                ]
            },
            {
                "pattern": "(\\w*\\s+)1",
                "log": "w 1",
                "end_match": "1",
                "captured_groups": [
                    "w "
                ]
            },
            {
                "pattern": " (\\w*)\\s+1",
                "log": " Wazuh 1",
                "end_match": "1",
                "captured_groups": [
                    "Wazuh"
                ]
            },
            {
                "pattern": "^\\w*\\s+$",
                "log": "w ",
                "end_match": " ",
                "captured_groups": []
            },
            {
                "ignore_result": true,
                "__known_issue": "Matches but if the regex ends with a token with the quantifier '+' or '*', then it does not return the pointer to the last character matched, as it should be. BUG 3 of issue: https://github.com/wazuh/wazuh/issues/14420",
                "pattern": "^\\w*\\s+$",
                "log": "Wazuh  ",
                "end_match": " ",
                "captured_groups": []
            },
            {
                "pattern": "^(\\w*)\\s+$",
                "log": "w ",
                "end_match": " ",
                "captured_groups": [
                    "w"
                ]
            },
            {
                "pattern": "^(\\w*)\\s+$",
                "log": "w ",
                "end_match": " ",
                "captured_groups": [
                    "w"
                ]
            },
            {
                "pattern": "^(\\w*\\s+)$",
                "log": "w ",
                "end_match": " ",
                "captured_groups": [
                    "w "
                ]
            },
            {
                "description": "Dont match.",
                "pattern": "^\\w*\\s+$",
                "log": "Wazuh -",
                "end_match": null,
                "captured_groups": []
            },
            {
                "description": "Dont match.",
                "pattern": "^(\\w*\\s+)$",
                "log": "Wazuh -",
                "end_match": null,
                "captured_groups": []
            }
        ]
    },
    {
        "description": "[Functionality] Lazy-Greedy behavior duality: Regex composed by a backslashed token with a '+' quantifier followed by a token that has the '*' quantifier, where the last token does include the charmap of the first one.",
        "batch_test": [
            {
                "pattern": "\\w*\\s*",
                "log": "w",
                "end_match": "w",
                "captured_groups": []
            },
            {
                "pattern": "\\w*\\s*",
                "__known_issue": "Matches but if the regex ends with a token with the quantifier '+' or '*', then it does not return the pointer to the last character matched, as it should be. BUG 3 of issue: https://github.com/wazuh/wazuh/issues/14420",
                "ignore_result": true,
                "log": "w ",
                "end_match": " ",
                "captured_groups": []
            },
            {
                "pattern": "(\\w*\\s*)",
                "log": "w",
                "end_match": "w",
                "captured_groups": [
                    "w"
                ]
            },
            {
                "pattern": "(\\w*\\s*)",
                "__known_issue": "When the regex consists only of tokens with '*' quantifiers, then it always matches. When it matches having 0 matching characters, then it returns the pointer poiting to one byte before the beginning of the string. BUG Issue: https://github.com/Wazuh/Wazuh/issues/14249",
                "__known_issue_2:": "Matches but if the regex ends with a token with the quantifier '+' or '*', then it does not return the pointer to the last character matched, as it should be. BUG 3 of issue: https://github.com/wazuh/wazuh/issues/14420",
                "skip_test": true,
                "log": " ",
                "end_match": " ",
                "captured_groups": [
                    " "
                ]
            },
            {
                "pattern": "(\\w*\\s*)",
                "log": "Wazuh",
                "end_match": "h",
                "captured_groups": [
                    "Wazuh"
                ]
            },
            {
                "ignore_result": true,
                "debug": false,
                "__known_issue": "Matches but if the regex ends with a token with the quantifier '+' or '*', then it does not return the pointer to the last character matched, as it should be. BUG 3 of issue: https://github.com/wazuh/wazuh/issues/14420",
                "pattern": "(\\w*\\s*)",
                "log": "w ",
                "end_match": " ",
                "captured_groups": [
                    "w "
                ]
            },
            {
                "description": "Min size, with group",
                "pattern": "(\\w*)\\s*",
                "log": "w",
                "end_match": "w",
                "captured_groups": [
                    "w"
                ]
            },
            {
                "ignore_result": true,
                "__known_issue": "Matches but if the regex ends with a token with the quantifier '+' or '*', then it does not return the pointer to the last character matched, as it should be. BUG 3 of issue: https://github.com/wazuh/wazuh/issues/14420",
                "pattern": "(\\w*)\\s*",
                "log": "w ",
                "end_match": " ",
                "captured_groups": [
                    "w"
                ]
            },
            {
                "pattern": "\\w*\\s*",
                "ignore_result": true,
                "debug": false,
                "__known_issue": "Matches but if the regex ends with a token with the quantifier '+' or '*', then it does not return the pointer to the last character matched, as it should be. BUG 3 of issue: https://github.com/wazuh/wazuh/issues/14420",
                "log": "Wazuh ",
                "end_match": " ",
                "captured_groups": []
            },
            {
                "description": "Other size. With group",
                "ignore_result": true,
                "debug": false,
                "__known_issue": "Matches but if the regex ends with a token with the quantifier '+' or '*', then it does not return the pointer to the last character matched, as it should be. BUG 3 of issue: https://github.com/wazuh/wazuh/issues/14420",
                "pattern": "(\\w*\\s*)",
                "log": "Wazuh ",
                "end_match": " ",
                "captured_groups": [
                    "Wazuh "
                ]
            },
            {
                "__known_issue": "It should match but does not, adjacent capture groups are not supported. BUG 1 of issue: https://github.com/wazuh/wazuh/issues/14420",
                "ignore_result": true,
                "pattern": "(\\w*)(\\s*)",
                "log": "Wazuh ",
                "end_match": " ",
                "captured_groups": [
                    "Wazuh",
                    " "
                ]
            },
            {
                "__known_issue": "It should match but does not, adjacent capture groups are not supported. BUG 1 of issue: https://github.com/wazuh/wazuh/issues/14420",
                "ignore_result": true,
                "pattern": "(\\w*)(\\s*)",
                "log": " ",
                "end_match": " ",
                "captured_groups": [
                    "",
                    " "
                ]
            },
            {
                "__known_issue": "It should match but does not, adjacent capture groups are not supported. BUG 1 of issue: https://github.com/wazuh/wazuh/issues/14420",
                "ignore_result": true,
                "pattern": "(\\w*)(\\s*)",
                "log": "w",
                "end_match": " ",
                "captured_groups": [
                    "",
                    " "
                ]
            },
            {
                "__known_issue": "It should match but does not, adjacent capture groups are not supported. BUG 1 of issue: https://github.com/wazuh/wazuh/issues/14420",
                "ignore_result": true,
                "debug": false,
                "pattern": "(\\w*)(\\s*)",
                "log": "",
                "end_match": "",
                "captured_groups": [
                    "",
                    ""
                ]
            },
            {
                "description": "2 groups no consecutive, and opcional.",
                "pattern": "(\\w*)\\d+(\\s*)",
                "ignore_result": true,
                "__known_issue": "It should match but does not, adjacent capture groups are not supported. BUG 1 of issue: https://github.com/wazuh/wazuh/issues/14420",
                "log": "Wazuh ",
                "end_match": null,
                "captured_groups": []
            },
            {
                "description": "2 groups no consecutive, and opcional",
                "pattern": "(\\w*)\\d+(\\s*)",
                "ignore_result": true,
                "__known_issue": "Matches but if the regex ends with a token with the quantifier '+' or '*', then it does not return the pointer to the last character matched, as it should be. BUG 3 of issue: https://github.com/wazuh/wazuh/issues/14420",
                "log": "Wazuh123 ",
                "end_match": " ",
                "captured_groups": [
                    "Wazuh",
                    " "
                ]
            },
            {
                "description": "2 groups no consecutive",
                "pattern": "(\\w*)\\d*(\\s*)",
                "ignore_result": true,
                "__known_issue": "Matches but if the regex ends with a token with the quantifier '+' or '*', then it does not return the pointer to the last character matched, as it should be. BUG 3 of issue: https://github.com/wazuh/wazuh/issues/14420",
                "log": "Wazuh123 ",
                "end_match": " ",
                "captured_groups": [
                    "Wazuh",
                    " "
                ]
            },
            {
                "pattern": "\\w*\\s*1",
                "log": "Wazuh 1",
                "end_match": "1",
                "captured_groups": []
            },
            {
                "pattern": "(\\w*)\\s*1",
                "log": "w 1",
                "end_match": "1",
                "captured_groups": [
                    "w"
                ]
            },
            {
                "pattern": "(\\w*\\s*)1",
                "log": "w 1",
                "end_match": "1",
                "captured_groups": [
                    "w "
                ]
            },
            {
                "pattern": " (\\w*)\\s*1",
                "log": " Wazuh 1",
                "end_match": "1",
                "captured_groups": [
                    "Wazuh"
                ]
            },
            {
                "pattern": "^\\w*\\s*$",
                "ignore_result": true,
                "__known_issue": "Matches but if the regex ends with a token with the quantifier '+' or '*', then it does not return the pointer to the last character matched, as it should be. BUG 3 of issue: https://github.com/wazuh/wazuh/issues/14420",
                "log": "w ",
                "end_match": " ",
                "captured_groups": []
            },
            {
                "ignore_result": true,
                "__known_issue": "Matches but if the regex ends with a token with the quantifier '+' or '*', then it does not return the pointer to the last character matched, as it should be. BUG 3 of issue: https://github.com/wazuh/wazuh/issues/14420",
                "pattern": "^\\w*\\s*$",
                "log": "Wazuh  ",
                "end_match": " ",
                "captured_groups": []
            },
            {
                "pattern": "^(\\w*)\\s*$",
                "ignore_result": true,
                "__known_issue": "Matches but if the regex ends with a token with the quantifier '+' or '*', then it does not return the pointer to the last character matched, as it should be. BUG 3 of issue: https://github.com/wazuh/wazuh/issues/14420",
                "log": "w ",
                "end_match": " ",
                "captured_groups": [
                    "w"
                ]
            },
            {
                "pattern": "^(\\w*)\\s*$",
                "ignore_result": true,
                "__known_issue": "Matches but if the regex ends with a token with the quantifier '+' or '*', then it does not return the pointer to the last character matched, as it should be. BUG 3 of issue: https://github.com/wazuh/wazuh/issues/14420",
                "log": "w ",
                "end_match": " ",
                "captured_groups": [
                    "w"
                ]
            },
            {
                "pattern": "^(\\w*\\s*)$",
                "__known_issue": "Matches but if the regex ends with a token with the quantifier '+' or '*', then it does not return the pointer to the last character matched, as it should be. BUG 3 of issue: https://github.com/wazuh/wazuh/issues/14420",
                "ignore_result": true,
                "log": "w ",
                "end_match": " ",
                "captured_groups": [
                    "w "
                ]
            },
            {
                "description": "Dont match.",
                "pattern": "^\\w*\\s*$",
                "log": "Wazuh -",
                "end_match": null,
                "captured_groups": []
            },
            {
                "description": "Dont match.",
                "pattern": "^(\\w*\\s*)$",
                "log": "Wazuh -",
                "end_match": null,
                "captured_groups": []
            }
        ]
    },
    {
        "description": "[Functionality] Lazy-Greedy behavior duality: Regex composed by backslashed tokens with '*' quantifiers. Test the 'st_error', 'pt_error[]' and 'pt_error_str[]' for parcial matches and rewind.",
        "batch_test": [
            {
                "description": "Saves and restores the first position error.",
                "pattern": "\\w*_1 \\w*_2 \\w*_3 \\w*_4 \\w*_5 \\w*_6",
                "log": "wa_11 wa_1 wa_2 wa_3 wa_4 wa_5 wa_6",
                "end_match": "6",
                "captured_groups": []
            },
            {
                "description": "Saves and restores the second position error.",
                "pattern": "\\w*_1 \\w*_2 \\w*_3 \\w*_4 \\w*_5 \\w*_6",
                "log": "wa_1 wa_22 wa_1 wa_2 wa_3 wa_4 wa_5 wa_6",
                "end_match": "6",
                "captured_groups": []
            },
            {
                "description": "Saves and restores the third position error.",
                "pattern": "\\w*_1 \\w*_2 \\w*_3 \\w*_4 \\w*_5 \\w*_6",
                "log": "wa_1 wa_2 wa_1 wa_2 wa_3 wa_4 wa_5 wa_6",
                "end_match": "6",
                "captured_groups": []
            },
            {
                "description": "Saves and restores the fourth position error.",
                "pattern": "\\w*_1 \\w*_2 \\w*_3 \\w*_4 \\w*_5 \\w*_6",
                "log": "wa_1 wa_2 wa_3 wa_1 wa_2 wa_3 wa_4 wa_5 wa_6",
                "end_match": "6",
                "captured_groups": []
            },
            {
                "description": "Saves and restores the fifth position error.",
                "pattern": "\\w*_1 \\w*_2 \\w*_3 \\w*_4 \\w*_5 \\w*_6",
                "log": "wa_1 wa_2 wa_3 wa_4 wa_1 wa_2 wa_3 wa_4 wa_5 wa_6",
                "end_match": "6",
                "captured_groups": []
            },
            {
                "description": "Saves and restores the sixth position error.",
                "pattern": "\\w*_1 \\w*_2 \\w*_3 \\w*_4 \\w*_5 \\w*_6",
                "log": "wa_1 wa_2 wa_3 wa_4 wa_5 wa_1 wa_2 wa_3 wa_4 wa_5 wa_6",
                "end_match": "6",
                "captured_groups": []
            },
            {
                "description": "Saves and restores the first position error. But the first should match with the next character.",
                "pattern": "\\w*1 \\w*2 \\w*3 \\w*4 \\w*5 \\w*6",
                "log": "z1x1 x2 x3 x4 x5 x6",
                "end_match": "6",
                "captured_groups": []
            },
            {
                "description": "Saves and restores the second position error. But the second should match with the next character.",
                "pattern": "\\w*1 \\w*2 \\w*3 \\w*4 \\w*5 \\w*6",
                "log": "z1 x2x2 x3 x4 x5 x6",
                "end_match": "6",
                "captured_groups": []
            },
            {
                "description": "Saves and restores the  third position error. But the third should match with the next character.",
                "pattern": "\\w*1 \\w*2 \\w*3 \\w*4 \\w*5 \\w*6",
                "log": "z1 x2x2 x3 x4 x5 x6",
                "end_match": "6",
                "captured_groups": []
            },
            {
                "description": "Saves and restores the fourth position error. But the fourth should match with the next character.",
                "pattern": "\\w*1 \\w*2 \\w*3 \\w*4 \\w*5 \\w*6",
                "log": "z1 x2 x3 x4x4 x5 x6",
                "end_match": "6",
                "captured_groups": []
            },
            {
                "description": "Saves and restores the fifth position error. But the fifth should match with the next character.",
                "pattern": "\\w*1 \\w*2 \\w*3 \\w*4 \\w*5 \\w*6",
                "__known_issue": "It should match but does not, as the states stack is limited to 4 states. BUG 6 of issue: https://github.com/wazuh/wazuh/issues/14420",
                "ignore_result": true,
                "log": "z1 x2 x3 x4 x5x5 x6",
                "end_match": "6",
                "captured_groups": []
            },
            {
                "description": "Saves and restores the sixth position error. But the sixth should match with the next character.",
                "pattern": "\\w*1 \\w*2 \\w*3 \\w*4 \\w*5 \\w*6",
                "log": "z1 x2 x3 x4 x5 x6x6",
                "__known_issue": "It should match but does not, as the states stack is limited to 4 states. BUG 6 of issue: https://github.com/wazuh/wazuh/issues/14420",
                "ignore_result": true,
                "end_match": "6",
                "captured_groups": []
            }
        ]
    },
    {
        "description": "[Coverage] Loop on all sub patterns without capture groups",
        "batch_test": [
            {
                "description": "Loop on all sub patterns, without match",
                "pattern": "^hi|bye$|^$",
                "log": "123456",
                "end_match": null,
                "captured_groups": []
            },
            {
                "description": "Loop on all sub patterns, match",
                "pattern": "^hi|bye$|^$|\\w+\\d.|\\p*",
                "log": "123456.",
                "end_match": ".",
                "captured_groups": []
            }
        ]
    },
    {
        "description": "[Memory test] regex_matching alloc test: copy reg size.",
        "batch_test": [
            {
                "description": "Create 20 patterns, 22 capture groups and match last.",
                "__sub_string_size": "((36 gruopos x 2 know bug) + 1 null)  x 8 size = 584 bytes",
                "__prts_main_array": " (20 pattern + 1 null)  x 8 size = 168 bytes",
                "__prts_items_array": "size of array d_size->prts_str_size == size of array prts_str == prts_str_alloc_size = 168",
                "__prts_items_array_1": "(1 group x2 + 1 null)  x 8 size = 24 bytes",
                "__prts_items_array_2": "(4 group x2 + 1 null)  x 8 size = 72 bytes",
                "__prts_items_array_3": "(5 group x2 + 1 null)  x 8 size = 88 bytes",
                "__prts_items_array_4": "(6 group x2 + 1 null)  x 8 size = 104 bytes",
                "__prts_items_array_5": "(7 group x2 + 1 null)  x 8 size = 120 bytes",
                "__prts_items_array_6": "(8 group x2 + 1 null)  x 8 size = 136 bytes",
                "__prts_items_array_7": "(9 group x2 + 1 null)  x 8 size = 152 bytes",
                "__prts_items_array_8": "(10 group x2 + 1 null)  x 8 size = 168 bytes",
                "__prts_items_array_9": "(11 group x2 + 1 null)  x 8 size = 184 bytes",
                "__prts_items_array_10": "(12 group x2 + 1 null)  x 8 size = 200 bytes",
                "__prts_items_array_11": "(13 group x2 + 1 null)  x 8 size = 216 bytes",
                "__prts_items_array_12": "(14 group x2 + 1 null)  x 8 size = 232 bytes",
                "__prts_items_array_13": "(15 group x2 + 1 null)  x 8 size = 248 bytes",
                "__prts_items_array_14": "(16 group x2 + 1 null)  x 8 size = 264 bytes",
                "__prts_items_array_15": "(17 group x2 + 1 null)  x 8 size = 280 bytes",
                "__prts_items_array_16": "(18 group x2 + 1 null)  x 8 size = 296 bytes",
                "__prts_items_array_17": "(19 group x2 + 1 null)  x 8 size = 312 bytes",
                "__prts_items_array_18": "(20 group x2 + 1 null)  x 8 size = 328 bytes",
                "__prts_items_array_19": "(21 group x2 + 1 null)  x 8 size = 344 bytes",
                "__prts_items_array_20": "(36 group x2 + 1 null)  x 8 size = 584 bytes",
                "__prts_items_array_21": "0x0",
                "pattern": "^01cg field_01=(\\d+)|^04cg field_01=(\\d+) field_02=(\\d+) field_03=(\\d+) field_04=(\\d+)|^05cg field_01=(\\d+) field_02=(\\d+) field_03=(\\d+) field_04=(\\d+) field_05=(\\d+)|^06cg field_01=(\\d+) field_02=(\\d+) field_03=(\\d+) field_04=(\\d+) field_05=(\\d+) field_06=(\\d+)|^07cg field_01=(\\d+) field_02=(\\d+) field_03=(\\d+) field_04=(\\d+) field_05=(\\d+) field_06=(\\d+) field_07=(\\d+)|^08cg field_01=(\\d+) field_02=(\\d+) field_03=(\\d+) field_04=(\\d+) field_05=(\\d+) field_06=(\\d+) field_07=(\\d+) field_08=(\\d+)|^09cg field_01=(\\d+) field_02=(\\d+) field_03=(\\d+) field_04=(\\d+) field_05=(\\d+) field_06=(\\d+) field_07=(\\d+) field_08=(\\d+) field_09=(\\d+)|^10cg field_01=(\\d+) field_02=(\\d+) field_03=(\\d+) field_04=(\\d+) field_05=(\\d+) field_06=(\\d+) field_07=(\\d+) field_08=(\\d+) field_09=(\\d+) field_10=(\\d+)|^11cg field_01=(\\d+) field_02=(\\d+) field_03=(\\d+) field_04=(\\d+) field_05=(\\d+) field_06=(\\d+) field_07=(\\d+) field_08=(\\d+) field_09=(\\d+) field_10=(\\d+) field_11=(\\d+)|^12cg field_01=(\\d+) field_02=(\\d+) field_03=(\\d+) field_04=(\\d+) field_05=(\\d+) field_06=(\\d+) field_07=(\\d+) field_08=(\\d+) field_09=(\\d+) field_10=(\\d+) field_11=(\\d+) field_12=(\\d+)|^13cg field_01=(\\d+) field_02=(\\d+) field_03=(\\d+) field_04=(\\d+) field_05=(\\d+) field_06=(\\d+) field_07=(\\d+) field_08=(\\d+) field_09=(\\d+) field_10=(\\d+) field_11=(\\d+) field_12=(\\d+) field_13=(\\d+)|^14cg field_01=(\\d+) field_02=(\\d+) field_03=(\\d+) field_04=(\\d+) field_05=(\\d+) field_06=(\\d+) field_07=(\\d+) field_08=(\\d+) field_09=(\\d+) field_10=(\\d+) field_11=(\\d+) field_12=(\\d+) field_13=(\\d+) field_14=(\\d+)|^15cg field_01=(\\d+) field_02=(\\d+) field_03=(\\d+) field_04=(\\d+) field_05=(\\d+) field_06=(\\d+) field_07=(\\d+) field_08=(\\d+) field_09=(\\d+) field_10=(\\d+) field_11=(\\d+) field_12=(\\d+) field_13=(\\d+) field_14=(\\d+) field_15=(\\d+)|^16cg field_01=(\\d+) field_02=(\\d+) field_03=(\\d+) field_04=(\\d+) field_05=(\\d+) field_06=(\\d+) field_07=(\\d+) field_08=(\\d+) field_09=(\\d+) field_10=(\\d+) field_11=(\\d+) field_12=(\\d+) field_13=(\\d+) field_14=(\\d+) field_15=(\\d+) field_16=(\\d+)|^17cg field_01=(\\d+) field_02=(\\d+) field_03=(\\d+) field_04=(\\d+) field_05=(\\d+) field_06=(\\d+) field_07=(\\d+) field_08=(\\d+) field_09=(\\d+) field_10=(\\d+) field_11=(\\d+) field_12=(\\d+) field_13=(\\d+) field_14=(\\d+) field_15=(\\d+) field_16=(\\d+) field_17=(\\d+)|^18cg field_01=(\\d+) field_02=(\\d+) field_03=(\\d+) field_04=(\\d+) field_05=(\\d+) field_06=(\\d+) field_07=(\\d+) field_08=(\\d+) field_09=(\\d+) field_10=(\\d+) field_11=(\\d+) field_12=(\\d+) field_13=(\\d+) field_14=(\\d+) field_15=(\\d+) field_16=(\\d+) field_17=(\\d+) field_18=(\\d+)|^19cg field_01=(\\d+) field_02=(\\d+) field_03=(\\d+) field_04=(\\d+) field_05=(\\d+) field_06=(\\d+) field_07=(\\d+) field_08=(\\d+) field_09=(\\d+) field_10=(\\d+) field_11=(\\d+) field_12=(\\d+) field_13=(\\d+) field_14=(\\d+) field_15=(\\d+) field_16=(\\d+) field_17=(\\d+) field_18=(\\d+) field_19=(\\d+)|^20cg field_01=(\\d+) field_02=(\\d+) field_03=(\\d+) field_04=(\\d+) field_05=(\\d+) field_06=(\\d+) field_07=(\\d+) field_08=(\\d+) field_09=(\\d+) field_10=(\\d+) field_11=(\\d+) field_12=(\\d+) field_13=(\\d+) field_14=(\\d+) field_15=(\\d+) field_16=(\\d+) field_17=(\\d+) field_18=(\\d+) field_19=(\\d+) field_20=(\\d+)|^21cg field_01=(\\d+) field_02=(\\d+) field_03=(\\d+) field_04=(\\d+) field_05=(\\d+) field_06=(\\d+) field_07=(\\d+) field_08=(\\d+) field_09=(\\d+) field_10=(\\d+) field_11=(\\d+) field_12=(\\d+) field_13=(\\d+) field_14=(\\d+) field_15=(\\d+) field_16=(\\d+) field_17=(\\d+) field_18=(\\d+) field_19=(\\d+) field_20=(\\d+) field_21=(\\d+)|^36cg field_01=(\\d+) field_02=(\\d+) field_03=(\\d+) field_04=(\\d+) field_05=(\\d+) field_06=(\\d+) field_07=(\\d+) field_08=(\\d+) field_09=(\\d+) field_10=(\\d+) field_11=(\\d+) field_12=(\\d+) field_13=(\\d+) field_14=(\\d+) field_15=(\\d+) field_16=(\\d+) field_17=(\\d+) field_18=(\\d+) field_19=(\\d+) field_20=(\\d+) field_21=(\\d+) field_22=(\\d+) field_23=(\\d+) field_24=(\\d+) field_25=(\\d+) field_26=(\\d+) field_27=(\\d+) field_28=(\\d+) field_29=(\\d+) field_30=(\\d+) field_31=(\\d+) field_32=(\\d+) field_33=(\\d+) field_34=(\\d+) field_35=(\\d+) field_36=(\\d\\d\\d)",
                "log": "36cg field_01=001 field_02=002 field_03=003 field_04=004 field_05=005 field_06=006 field_07=007 field_08=008 field_09=009 field_10=010 field_11=011 field_12=012 field_13=013 field_14=014 field_15=015 field_16=016 field_17=017 field_18=018 field_19=019 field_20=020 field_21=021 field_22=022 field_23=023 field_24=024 field_25=025 field_26=026 field_27=027 field_28=028 field_29=029 field_30=030 field_31=031 field_32=032 field_33=033 field_34=034 field_35=035 field_36=036",
                "end_match": "6",
                "captured_groups": [
                    "001",
                    "002",
                    "003",
                    "004",
                    "005",
                    "006",
                    "007",
                    "008",
                    "009",
                    "010",
                    "011",
                    "012",
                    "013",
                    "014",
                    "015",
                    "016",
                    "017",
                    "018",
                    "019",
                    "020",
                    "021",
                    "022",
                    "023",
                    "024",
                    "025",
                    "026",
                    "027",
                    "028",
                    "029",
                    "030",
                    "031",
                    "032",
                    "033",
                    "034",
                    "035",
                    "036"
                ]
            }
        ]
    },
    {
        "description": "[Memory test] regex_matching expand test: Incremental capture groups and match last.",
        "batch_test": [
            {
                "description": "Inizialize regex matching with capture grup, min size (1 patter, 1 capture).",
                "__sub_string_size": "((1 pattern x 2 know bug) + 1 null)  x 8 size = 24 bytes",
                "__prts_main_array": " (1 pattern + 1 null)  x 8 size = 16 bytes",
                "__prts_items_array": "size of array d_size->prts_str_size == size of array prts_str == prts_str_alloc_size = 16",
                "__prts_items_array_1": "(1 group x2 + 1 null)  x 8 size = 24 bytes",
                "__prts_array_2": "0x0",
                "pattern": "hi (\\w+).",
                "log": "Hi Wazuh.",
                "end_match": ".",
                "captured_groups": [
                    "Wazuh"
                ]
            },
            {
                "description": "Resize x 36 incremental capture groups and match.",
                "__sub_string_size": "((36 gruopos x 2 know bug) + 1 null)  x 8 size = 584 bytes",
                "__prts_main_array": " (1 pattern + 1 null)  x 8 size = 16 bytes",
                "__prts_items_array": "size of array d_size->prts_str_size == size of array prts_str == prts_str_alloc_size = 16",
                "__prts_items_array_1": "(1 group x2 + 1 null)  x 8 size = 24 bytes",
                "__prts_items_array_2": "(4 group x2 + 1 null)  x 8 size = 72 bytes",
                "__prts_items_array_3": "(5 group x2 + 1 null)  x 8 size = 88 bytes",
                "__prts_items_array_4": "(6 group x2 + 1 null)  x 8 size = 104 bytes",
                "__prts_items_array_5": "(7 group x2 + 1 null)  x 8 size = 120 bytes",
                "__prts_items_array_6": "(8 group x2 + 1 null)  x 8 size = 136 bytes",
                "__prts_items_array_7": "(9 group x2 + 1 null)  x 8 size = 152 bytes",
                "__prts_items_array_8": "(10 group x2 + 1 null)  x 8 size = 168 bytes",
                "__prts_items_array_9": "(11 group x2 + 1 null)  x 8 size = 184 bytes",
                "__prts_items_array_10": "(12 group x2 + 1 null)  x 8 size = 200 bytes",
                "__prts_items_array_11": "(13 group x2 + 1 null)  x 8 size = 216 bytes",
                "__prts_items_array_12": "(14 group x2 + 1 null)  x 8 size = 232 bytes",
                "__prts_items_array_13": "(15 group x2 + 1 null)  x 8 size = 248 bytes",
                "__prts_items_array_14": "(16 group x2 + 1 null)  x 8 size = 264 bytes",
                "__prts_items_array_15": "(17 group x2 + 1 null)  x 8 size = 280 bytes",
                "__prts_items_array_16": "(18 group x2 + 1 null)  x 8 size = 296 bytes",
                "__prts_items_array_17": "(19 group x2 + 1 null)  x 8 size = 312 bytes",
                "__prts_items_array_18": "(20 group x2 + 1 null)  x 8 size = 328 bytes",
                "__prts_items_array_19": "(21 group x2 + 1 null)  x 8 size = 344 bytes",
                "__prts_items_array_20": "(36 group x2 + 1 null)  x 8 size = 584 bytes",
                "__prts_items_array_21": "0x0",
                "pattern": "^36cg field_01=(\\d+) field_02=(\\d+) field_03=(\\d+) field_04=(\\d+) field_05=(\\d+) field_06=(\\d+) field_07=(\\d+) field_08=(\\d+) field_09=(\\d+) field_10=(\\d+) field_11=(\\d+) field_12=(\\d+) field_13=(\\d+) field_14=(\\d+) field_15=(\\d+) field_16=(\\d+) field_17=(\\d+) field_18=(\\d+) field_19=(\\d+) field_20=(\\d+) field_21=(\\d+) field_22=(\\d+) field_23=(\\d+) field_24=(\\d+) field_25=(\\d+) field_26=(\\d+) field_27=(\\d+) field_28=(\\d+) field_29=(\\d+) field_30=(\\d+) field_31=(\\d+) field_32=(\\d+) field_33=(\\d+) field_34=(\\d+) field_35=(\\d+) field_36=(\\d\\d\\d)",
                "log": "36cg field_01=001 field_02=002 field_03=003 field_04=004 field_05=005 field_06=006 field_07=007 field_08=008 field_09=009 field_10=010 field_11=011 field_12=012 field_13=013 field_14=014 field_15=015 field_16=016 field_17=017 field_18=018 field_19=019 field_20=020 field_21=021 field_22=022 field_23=023 field_24=024 field_25=025 field_26=026 field_27=027 field_28=028 field_29=029 field_30=030 field_31=031 field_32=032 field_33=033 field_34=034 field_35=035 field_36=036",
                "end_match": "6",
                "captured_groups": [
                    "001",
                    "002",
                    "003",
                    "004",
                    "005",
                    "006",
                    "007",
                    "008",
                    "009",
                    "010",
                    "011",
                    "012",
                    "013",
                    "014",
                    "015",
                    "016",
                    "017",
                    "018",
                    "019",
                    "020",
                    "021",
                    "022",
                    "023",
                    "024",
                    "025",
                    "026",
                    "027",
                    "028",
                    "029",
                    "030",
                    "031",
                    "032",
                    "033",
                    "034",
                    "035",
                    "036"
                ]
            },
            {
                "description": "Go back to 1 pattern and 1 capture groups.",
                "__sub_string_size": "((1 pattern x 2 know bug) + 1 null)  x 8 size = 24 bytes",
                "__prts_main_array": " (1 pattern + 1 null)  x 8 size = 16 bytes",
                "__prts_items_array": "size of array d_size->prts_str_size == size of array prts_str == prts_str_alloc_size = 16",
                "__prts_items_array_1": "(1 group x2 + 1 null)  x 8 size = 24 bytes",
                "__prts_array_2": "0x0",
                "pattern": "hi (\\w+).",
                "log": "Hi Wazuh.",
                "end_match": ".",
                "captured_groups": [
                    "Wazuh"
                ]
            }
        ]
    },
    {
        "description": "[Memory test] regex_matching expand test: Incremental patterns and match last.",
        "batch_test": [
            {
                "description": "Inizialize regex matching with a capture group, min size (1 patter, 1 capture).",
                "__sub_string_size": "((1 pattern x 2 know bug) + 1 null)  x 8 size = 24 bytes",
                "__prts_main_array": " (1 pattern + 1 null)  x 8 size = 16 bytes",
                "__prts_items_array": "size of array d_size->prts_str_size == size of array prts_str == prts_str_alloc_size = 16",
                "__prts_items_array_1": "(1 group x2 + 1 null)  x 8 size = 24 bytes",
                "__prts_array_2": "0x0",
                "pattern": "hi (\\w+).",
                "log": "Hi Wazuh.",
                "end_match": ".",
                "captured_groups": [
                    "Wazuh"
                ]
            },
            {
                "description": "Resize x 38 incremental patterns and match last.",
                "__sub_string_size": "((1 gruopos x 2 know bug) + 1 null)  x 8 size = 24 bytes",
                "__prts_main_array": " (38 pattern + 1 null)  x 8 size = 312 bytes",
                "__prts_items_array": "size of array d_size->prts_str_size == size of array prts_str == prts_str_alloc_size = 312",
                "__prts_items_array_1": "(1 group x2 + 1 null)  x 8 size = 24 bytes",
                "__prts_items_array_2": "(1 group x2 + 1 null)  x 8 size = 24 bytes",
                "__prts_items_array_3": "(1 group x2 + 1 null)  x 8 size = 24 bytes",
                "__prts_items_array_4": "(1 group x2 + 1 null)  x 8 size = 24 bytes",
                "__prts_items_array_5": "(1 group x2 + 1 null)  x 8 size = 24 bytes",
                "__prts_items_array_6": "(1 group x2 + 1 null)  x 8 size = 24 bytes",
                "__prts_items_array_7": "(1 group x2 + 1 null)  x 8 size = 24 bytes",
                "__prts_items_array_8": "(1 group x2 + 1 null)  x 8 size = 24 bytes",
                "__prts_items_array_9": "(1 group x2 + 1 null)  x 8 size = 24 bytes",
                "__prts_items_array_10": "(1 group x2 + 1 null)  x 8 size = 24 bytes",
                "__prts_items_array_11": "(1 group x2 + 1 null)  x 8 size = 24 bytes",
                "__prts_items_array_12": "(1 group x2 + 1 null)  x 8 size = 24 bytes",
                "__prts_items_array_13": "(1 group x2 + 1 null)  x 8 size = 24 bytes",
                "__prts_items_array_14": "(1 group x2 + 1 null)  x 8 size = 24 bytes",
                "__prts_items_array_15": "(1 group x2 + 1 null)  x 8 size = 24 bytes",
                "__prts_items_array_16": "(1 group x2 + 1 null)  x 8 size = 24 bytes",
                "__prts_items_array_17": "(1 group x2 + 1 null)  x 8 size = 24 bytes",
                "__prts_items_array_18": "(1 group x2 + 1 null)  x 8 size = 24 bytes",
                "__prts_items_array_19": "(1 group x2 + 1 null)  x 8 size = 24 bytes",
                "__prts_items_array_20": "(1 group x2 + 1 null)  x 8 size = 24 bytes",
                "__prts_items_array_21": "(1 group x2 + 1 null)  x 8 size = 24 bytes",
                "__prts_items_array_22": "(1 group x2 + 1 null)  x 8 size = 24 bytes",
                "__prts_items_array_23": "(1 group x2 + 1 null)  x 8 size = 24 bytes",
                "__prts_items_array_24": "(1 group x2 + 1 null)  x 8 size = 24 bytes",
                "__prts_items_array_25": "(1 group x2 + 1 null)  x 8 size = 24 bytes",
                "__prts_items_array_26": "(1 group x2 + 1 null)  x 8 size = 24 bytes",
                "__prts_items_array_27": "(1 group x2 + 1 null)  x 8 size = 24 bytes",
                "__prts_items_array_28": "(1 group x2 + 1 null)  x 8 size = 24 bytes",
                "__prts_items_array_29": "(1 group x2 + 1 null)  x 8 size = 24 bytes",
                "__prts_items_array_30": "(1 group x2 + 1 null)  x 8 size = 24 bytes",
                "__prts_items_array_31": "(1 group x2 + 1 null)  x 8 size = 24 bytes",
                "__prts_items_array_32": "(1 group x2 + 1 null)  x 8 size = 24 bytes",
                "__prts_items_array_33": "(1 group x2 + 1 null)  x 8 size = 24 bytes",
                "__prts_items_array_34": "(1 group x2 + 1 null)  x 8 size = 24 bytes",
                "__prts_items_array_35": "(1 group x2 + 1 null)  x 8 size = 24 bytes",
                "__prts_items_array_36": "(1 group x2 + 1 null)  x 8 size = 24 bytes",
                "__prts_items_array_37": "(1 group x2 + 1 null)  x 8 size = 24 bytes",
                "__prts_items_array_38": "(1 group x2 + 1 null)  x 8 size = 24 bytes",
                "__prts_items_array_39": "0x0",
                "pattern": "^01cg field_01=(\\d+)|^04cg field_01=(\\d+)|^05cg field_01=(\\d+)|^06cg field_01=(\\d+)|^07cg field_01=(\\d+)|^08cg field_01=(\\d+)|^09cg field_01=(\\d+)|^10cg field_01=(\\d+)|^11cg field_01=(\\d+)|^12cg field_01=(\\d+)|^13cg field_01=(\\d+)|^14cg field_01=(\\d+)|^15cg field_01=(\\d+)|^16cg field_01=(\\d+)|^17cg field_01=(\\d+)|^18cg field_01=(\\d+)|^19cg field_01=(\\d+)|^20cg field_01=(\\d+)|^21cg field_01=(\\d+)|^22cg field_01=(\\d+)|^23cg field_01=(\\d+)|^24cg field_01=(\\d+)|^25cg field_01=(\\d+)|^26cg field_01=(\\d+)|^27cg field_01=(\\d+)|^28cg field_01=(\\d+)|^29cg field_01=(\\d+)|^30cg field_01=(\\d+)|^31cg field_01=(\\d+)|^32cg field_01=(\\d+)|^33cg field_01=(\\d+)|^34cg field_01=(\\d+)|^35cg field_01=(\\d+)|^36cg field_01=(\\d+)|^37cg field_01=(\\d+)|^38cg field_01=(\\d\\d\\d)",
                "log": "38cg field_01=001",
                "end_match": "1",
                "captured_groups": [
                    "001"
                ]
            }
        ]
    },
    {
        "description": "[Memory test] regex_matching expand test: Incremental capture groups and patterns, then match last.",
        "batch_test": [
            {
                "description": "Inizialize regex matching with capture grup, min size (1 patter, 1 capture).",
                "__sub_string_size": "((1 pattern x 2 know bug) + 1 null)  x 8 size = 24 bytes",
                "__prts_main_array": " (1 pattern + 1 null)  x 8 size = 16 bytes",
                "__prts_items_array": "size of array d_size->prts_str_size == size of array prts_str == prts_str_alloc_size = 16",
                "__prts_items_array_1": "(1 group x2 + 1 null)  x 8 size = 24 bytes",
                "__prts_array_2": "0x0",
                "pattern": "hi (\\w+).",
                "log": "Hi Wazuh.",
                "end_match": ".",
                "captured_groups": [
                    "Wazuh"
                ]
            },
            {
                "description": "Resize x 20 patterns, 2236 incremental capture groups and match last.",
                "__sub_string_size": "((36 gruopos x 2 know bug) + 1 null)  x 8 size = 584 bytes",
                "__prts_main_array": " (20 pattern + 1 null)  x 8 size = 168 bytes",
                "__prts_items_array": "size of array d_size->prts_str_size == size of array prts_str == prts_str_alloc_size = 168",
                "__prts_items_array_1": "(1 group x2 + 1 null)  x 8 size = 24 bytes",
                "__prts_items_array_2": "(4 group x2 + 1 null)  x 8 size = 72 bytes",
                "__prts_items_array_3": "(5 group x2 + 1 null)  x 8 size = 88 bytes",
                "__prts_items_array_4": "(6 group x2 + 1 null)  x 8 size = 104 bytes",
                "__prts_items_array_5": "(7 group x2 + 1 null)  x 8 size = 120 bytes",
                "__prts_items_array_6": "(8 group x2 + 1 null)  x 8 size = 136 bytes",
                "__prts_items_array_7": "(9 group x2 + 1 null)  x 8 size = 152 bytes",
                "__prts_items_array_8": "(10 group x2 + 1 null)  x 8 size = 168 bytes",
                "__prts_items_array_9": "(11 group x2 + 1 null)  x 8 size = 184 bytes",
                "__prts_items_array_10": "(12 group x2 + 1 null)  x 8 size = 200 bytes",
                "__prts_items_array_11": "(13 group x2 + 1 null)  x 8 size = 216 bytes",
                "__prts_items_array_12": "(14 group x2 + 1 null)  x 8 size = 232 bytes",
                "__prts_items_array_13": "(15 group x2 + 1 null)  x 8 size = 248 bytes",
                "__prts_items_array_14": "(16 group x2 + 1 null)  x 8 size = 264 bytes",
                "__prts_items_array_15": "(17 group x2 + 1 null)  x 8 size = 280 bytes",
                "__prts_items_array_16": "(18 group x2 + 1 null)  x 8 size = 296 bytes",
                "__prts_items_array_17": "(19 group x2 + 1 null)  x 8 size = 312 bytes",
                "__prts_items_array_18": "(20 group x2 + 1 null)  x 8 size = 328 bytes",
                "__prts_items_array_19": "(21 group x2 + 1 null)  x 8 size = 344 bytes",
                "__prts_items_array_20": "(36 group x2 + 1 null)  x 8 size = 584 bytes",
                "__prts_items_array_21": "0x0",
                "pattern": "^01cg field_01=(\\d+)|^04cg field_01=(\\d+) field_02=(\\d+) field_03=(\\d+) field_04=(\\d+)|^05cg field_01=(\\d+) field_02=(\\d+) field_03=(\\d+) field_04=(\\d+) field_05=(\\d+)|^06cg field_01=(\\d+) field_02=(\\d+) field_03=(\\d+) field_04=(\\d+) field_05=(\\d+) field_06=(\\d+)|^07cg field_01=(\\d+) field_02=(\\d+) field_03=(\\d+) field_04=(\\d+) field_05=(\\d+) field_06=(\\d+) field_07=(\\d+)|^08cg field_01=(\\d+) field_02=(\\d+) field_03=(\\d+) field_04=(\\d+) field_05=(\\d+) field_06=(\\d+) field_07=(\\d+) field_08=(\\d+)|^09cg field_01=(\\d+) field_02=(\\d+) field_03=(\\d+) field_04=(\\d+) field_05=(\\d+) field_06=(\\d+) field_07=(\\d+) field_08=(\\d+) field_09=(\\d+)|^10cg field_01=(\\d+) field_02=(\\d+) field_03=(\\d+) field_04=(\\d+) field_05=(\\d+) field_06=(\\d+) field_07=(\\d+) field_08=(\\d+) field_09=(\\d+) field_10=(\\d+)|^11cg field_01=(\\d+) field_02=(\\d+) field_03=(\\d+) field_04=(\\d+) field_05=(\\d+) field_06=(\\d+) field_07=(\\d+) field_08=(\\d+) field_09=(\\d+) field_10=(\\d+) field_11=(\\d+)|^12cg field_01=(\\d+) field_02=(\\d+) field_03=(\\d+) field_04=(\\d+) field_05=(\\d+) field_06=(\\d+) field_07=(\\d+) field_08=(\\d+) field_09=(\\d+) field_10=(\\d+) field_11=(\\d+) field_12=(\\d+)|^13cg field_01=(\\d+) field_02=(\\d+) field_03=(\\d+) field_04=(\\d+) field_05=(\\d+) field_06=(\\d+) field_07=(\\d+) field_08=(\\d+) field_09=(\\d+) field_10=(\\d+) field_11=(\\d+) field_12=(\\d+) field_13=(\\d+)|^14cg field_01=(\\d+) field_02=(\\d+) field_03=(\\d+) field_04=(\\d+) field_05=(\\d+) field_06=(\\d+) field_07=(\\d+) field_08=(\\d+) field_09=(\\d+) field_10=(\\d+) field_11=(\\d+) field_12=(\\d+) field_13=(\\d+) field_14=(\\d+)|^15cg field_01=(\\d+) field_02=(\\d+) field_03=(\\d+) field_04=(\\d+) field_05=(\\d+) field_06=(\\d+) field_07=(\\d+) field_08=(\\d+) field_09=(\\d+) field_10=(\\d+) field_11=(\\d+) field_12=(\\d+) field_13=(\\d+) field_14=(\\d+) field_15=(\\d+)|^16cg field_01=(\\d+) field_02=(\\d+) field_03=(\\d+) field_04=(\\d+) field_05=(\\d+) field_06=(\\d+) field_07=(\\d+) field_08=(\\d+) field_09=(\\d+) field_10=(\\d+) field_11=(\\d+) field_12=(\\d+) field_13=(\\d+) field_14=(\\d+) field_15=(\\d+) field_16=(\\d+)|^17cg field_01=(\\d+) field_02=(\\d+) field_03=(\\d+) field_04=(\\d+) field_05=(\\d+) field_06=(\\d+) field_07=(\\d+) field_08=(\\d+) field_09=(\\d+) field_10=(\\d+) field_11=(\\d+) field_12=(\\d+) field_13=(\\d+) field_14=(\\d+) field_15=(\\d+) field_16=(\\d+) field_17=(\\d+)|^18cg field_01=(\\d+) field_02=(\\d+) field_03=(\\d+) field_04=(\\d+) field_05=(\\d+) field_06=(\\d+) field_07=(\\d+) field_08=(\\d+) field_09=(\\d+) field_10=(\\d+) field_11=(\\d+) field_12=(\\d+) field_13=(\\d+) field_14=(\\d+) field_15=(\\d+) field_16=(\\d+) field_17=(\\d+) field_18=(\\d+)|^19cg field_01=(\\d+) field_02=(\\d+) field_03=(\\d+) field_04=(\\d+) field_05=(\\d+) field_06=(\\d+) field_07=(\\d+) field_08=(\\d+) field_09=(\\d+) field_10=(\\d+) field_11=(\\d+) field_12=(\\d+) field_13=(\\d+) field_14=(\\d+) field_15=(\\d+) field_16=(\\d+) field_17=(\\d+) field_18=(\\d+) field_19=(\\d+)|^20cg field_01=(\\d+) field_02=(\\d+) field_03=(\\d+) field_04=(\\d+) field_05=(\\d+) field_06=(\\d+) field_07=(\\d+) field_08=(\\d+) field_09=(\\d+) field_10=(\\d+) field_11=(\\d+) field_12=(\\d+) field_13=(\\d+) field_14=(\\d+) field_15=(\\d+) field_16=(\\d+) field_17=(\\d+) field_18=(\\d+) field_19=(\\d+) field_20=(\\d+)|^21cg field_01=(\\d+) field_02=(\\d+) field_03=(\\d+) field_04=(\\d+) field_05=(\\d+) field_06=(\\d+) field_07=(\\d+) field_08=(\\d+) field_09=(\\d+) field_10=(\\d+) field_11=(\\d+) field_12=(\\d+) field_13=(\\d+) field_14=(\\d+) field_15=(\\d+) field_16=(\\d+) field_17=(\\d+) field_18=(\\d+) field_19=(\\d+) field_20=(\\d+) field_21=(\\d+)|^36cg field_01=(\\d+) field_02=(\\d+) field_03=(\\d+) field_04=(\\d+) field_05=(\\d+) field_06=(\\d+) field_07=(\\d+) field_08=(\\d+) field_09=(\\d+) field_10=(\\d+) field_11=(\\d+) field_12=(\\d+) field_13=(\\d+) field_14=(\\d+) field_15=(\\d+) field_16=(\\d+) field_17=(\\d+) field_18=(\\d+) field_19=(\\d+) field_20=(\\d+) field_21=(\\d+) field_22=(\\d+) field_23=(\\d+) field_24=(\\d+) field_25=(\\d+) field_26=(\\d+) field_27=(\\d+) field_28=(\\d+) field_29=(\\d+) field_30=(\\d+) field_31=(\\d+) field_32=(\\d+) field_33=(\\d+) field_34=(\\d+) field_35=(\\d+) field_36=(\\d\\d\\d)",
                "log": "36cg field_01=001 field_02=002 field_03=003 field_04=004 field_05=005 field_06=006 field_07=007 field_08=008 field_09=009 field_10=010 field_11=011 field_12=012 field_13=013 field_14=014 field_15=015 field_16=016 field_17=017 field_18=018 field_19=019 field_20=020 field_21=021 field_22=022 field_23=023 field_24=024 field_25=025 field_26=026 field_27=027 field_28=028 field_29=029 field_30=030 field_31=031 field_32=032 field_33=033 field_34=034 field_35=035 field_36=036",
                "end_match": "6",
                "captured_groups": [
                    "001",
                    "002",
                    "003",
                    "004",
                    "005",
                    "006",
                    "007",
                    "008",
                    "009",
                    "010",
                    "011",
                    "012",
                    "013",
                    "014",
                    "015",
                    "016",
                    "017",
                    "018",
                    "019",
                    "020",
                    "021",
                    "022",
                    "023",
                    "024",
                    "025",
                    "026",
                    "027",
                    "028",
                    "029",
                    "030",
                    "031",
                    "032",
                    "033",
                    "034",
                    "035",
                    "036"
                ]
            }
        ]
    },
    {
        "description": "[Functionality] Supported expression tests - Character Maps [\\w, \\d, \\s, \\W, \\D, \\S, \\p, \\t, \\.].",
        "batch_test": [
            {
                "description": "\\w test: Includes all letters, digits, @ and _ characters.",
                "__knownIssue:": "The pattern was designed this way due to know issue. Workaround for '(\\w+)' pattern",
                "pattern": "(\\w+\\w)$",
                "log": "\t\r !\"#$%&()*+,./:;<=>?[\\]^`{|}~0123456789_-@ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz",
                "end_match": "z",
                "captured_groups": [
                    "0123456789_-@ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"
                ]
            },
            {
                "description": "\\d test: Only digits.",
                "__knownIssue:": "The pattern was designed this way due to know issue. Workaround for '(\\d+)' pattern",
                "pattern": "(\\d+\\d)$",
                "log": "\t\r !\"#$%&()*+,./:;<=>?[\\]^`{|}~_-@ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789",
                "end_match": "9",
                "captured_groups": [
                    "0123456789"
                ]
            },
            {
                "description": "\\s test: space character ' '.",
                "pattern": "(\\s+)",
                "log": "\t\r!\"#$%&()*+,./:;<=>?[\\]^`{|}~_-@ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789 ",
                "end_match": " ",
                "captured_groups": [
                    " "
                ]
            },
            {
                "description": "\\t test: tab character '\\t'.",
                "pattern": "(\\t+)",
                "log": "\r !\"#$%&()*+,./:;<=>?[\\]^`{|}~_-@ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\t",
                "end_match": "\t",
                "captured_groups": [
                    "\t"
                ]
            },
            {
                "description": "\\p test: symbols characters '()*+,-.:;<=>?[]!\"'#$%&|{}'.",
                "__knownIssue:": "The pattern was designed this way due to know issue. Workaround for '(\\p+)' pattern",
                "pattern": "(\\p+\\p)$",
                "log": "\r\t /\\^`~_@ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789()*+,-.:;<=>?[]!\"'#$%&|{}",
                "end_match": "}",
                "captured_groups": [
                    "()*+,-.:;<=>?[]!\"'#$%&|{}"
                ]
            },
            {
                "description": "\\W test: Anything not \\w.",
                "__knownIssue:": "The pattern was designed this way due to know issue. Workaround for '(\\W+)' pattern",
                "pattern": "(\\W+\\W)$",
                "log": "0123456789_-@ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\t\r !\"#$%&()*+,./:;<=>?[\\]^`{|}~",
                "end_match": "~",
                "captured_groups": [
                    "\t\r !\"#$%&()*+,./:;<=>?[\\]^`{|}~"
                ]
            },
            {
                "description": "\\D test: Anything not \\d.",
                "__knownIssue:": "The pattern was designed this way due to know issue. Workaround for '(\\D+)' pattern",
                "pattern": "(\\D+\\D)$",
                "log": "0123456789_-@ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\t !\"#$%&()*+,./:;<=>?[\\]^`{|}~",
                "end_match": "~",
                "captured_groups": [
                    "_-@ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\t !\"#$%&()*+,./:;<=>?[\\]^`{|}~"
                ]
            },
            {
                "description": "\\S test: Anything not \\s.",
                "__knownIssue:": "The pattern was designed this way due to know issue. Workaround for '(\\S+)' pattern",
                "pattern": "(\\S+\\S)$",
                "log": " \r\t!\"#$%&()*+,./:;<=>?[\\]^`{|}~_-@ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789",
                "end_match": "9",
                "captured_groups": [
                    "\r\t!\"#$%&()*+,./:;<=>?[\\]^`{|}~_-@ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789"
                ]
            },
            {
                "description": "\\. test: Anything",
                "__knownIssue:": "The pattern was designed this way due to know issue. Workaround for '(\\S+)' pattern",
                "pattern": "(\\.+\\.)$",
                "log": " \r\t!\"#$%&()*+,./:;<=>?[\\]^`{|}~_-@ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789",
                "end_match": "9",
                "captured_groups": [
                    " \r\t!\"#$%&()*+,./:;<=>?[\\]^`{|}~_-@ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789"
                ]
            }
        ]
    },
    {
        "description": "[Functionality] quantifiers (+ and *)",
        "batch_test": [
            {
                "description": "[+] It should not match since there are no characters of the type `\\d`.",
                "pattern": "(\\d+)",
                "log": "asd_ _qwe",
                "end_match": null,
                "captured_groups": []
            },
            {
                "description": "[+] It should match one time",
                "pattern": "(\\d+)",
                "log": "asd_1_qwe",
                "end_match": "1_qwe",
                "captured_groups": [
                    "1"
                ]
            },
            {
                "description": "[+]",
                "pattern": "(\\d+)",
                "ignore_result": true,
                "__knownIssue": "Link github issue ####",
                "debug": false,
                "log": "asd_12_qwe",
                "end_match": "2_qwe",
                "captured_groups": [
                    "12"
                ]
            },
            {
                "description": "[+]",
                "pattern": "(\\d+)",
                "ignore_result": true,
                "__knownIssue": "Link github issue ####",
                "log": "asd_123_qwe",
                "end_match": "3_qwe",
                "captured_groups": [
                    "123"
                ]
            },
            {
                "description": "[*] It should not match since there are no characters of the type `\\d`.",
                "skip_test": true,
                "pattern": "(\\d*)",
                "ignore_result": true,
                "log": " asd_ _qwe",
                "end_match": " asd_ _qwe",
                "captured_groups": [
                    ""
                ]
            },
            {
                "description": "[*] It should match one time",
                "skip_test": true,
                "pattern": "(\\d*)",
                "log": "asd_1_qwe",
                "end_match": "1_qwe",
                "captured_groups": [
                    "1"
                ]
            },
            {
                "description": "[*]",
                "skip_test": true,
                "pattern": "(\\d*)",
                "ignore_result": true,
                "__knownIssue": "Link github issue ####",
                "log": "asd_12_qwe",
                "end_match": "2_qwe",
                "captured_groups": [
                    "12"
                ]
            },
            {
                "description": "[+]",
                "skip_test": true,
                "pattern": "(\\d*)",
                "ignore_result": true,
                "__knownIssue": "Link github issue ####",
                "log": "asd_123_qwe",
                "end_match": "3_qwe",
                "captured_groups": [
                    "123"
                ]
            }
        ]
    },
    {
        "description": "[Functionality] Special characters escaping (\\$ \\( \\) \\\\ \\| \\<)",
        "batch_test": [
            {
                "description": "Using the '\\p+' token to test matching all the special characters with capture group.",
                "ignore_result": true,
                "__known_issue": "Bad end_match. Link github issue ####.",
                "pattern": "\\p+",
                "log": "$()|<",
                "end_match": "<",
                "captured_groups": []
            },
            {
                "description": "Using the '\\p+' token to test matching all the special characters with capture group.",
                "ignore_result": true,
                "__known_issue": "Bad end_match. Link github issue ####.",
                "pattern": "(\\p+)",
                "log": "$()|<",
                "end_match": "<",
                "captured_groups": [
                    "$()|<"
                ]
            },
            {
                "description": "Using all the tokens conditionally, except '\\p' and '\\.', to test matching all the special characters.",
                "ignore_result": true,
                "__known_issue": "Bad end_match. Link github issue ####.",
                "pattern": "\\w*\\d*\\s*\\t*\\W*\\D*\\S*",
                "log": "$()|<",
                "end_match": "<",
                "captured_groups": []
            },
            {
                "description": "Using all the tokens conditionally, except '\\p' and '\\.', to test matching all the special characters.",
                "ignore_result": true,
                "__known_issue": "Bad end_match. Link github issue ####.",
                "pattern": "\\w+|\\d+|\\s+|\\t+|\\W+|\\D+|\\S+|\\p+",
                "log": "$()|<",
                "end_match": "<",
                "captured_groups": []
            },
            {
                "description": "Using the '\\p+' token to test matching all the special characters with capture group. Note: the character '\\' is not captured by the token '\\p'.",
                "ignore_result": true,
                "__known_issue": "Link github issue ####",
                "pattern": "(\\p+)",
                "log": "Special characters are $()|<\\",
                "end_match": "\\",
                "captured_groups": [
                    "$()|<"
                ]
            },
            {
                "description": "Using the '\\p+' token to test matching all the special characters w/o capture group. Note: the character '\\' is not captured by the token '\\p'.",
                "pattern": "\\p+",
                "log": "Special characters are $()|<\\",
                "end_match": "\\",
                "captured_groups": []
            },
            {
                "description": "Using the '\\p*' token to test matching all the special characters with capture group. Note: the character '\\' is not captured by the token '\\p'.",
                "pattern": "Special characters are (\\p*)",
                "log": "Special characters are $()|<\\",
                "end_match": "<\\",
                "captured_groups": [
                    "$()|<"
                ]
            },
            {
                "description": "Using the '\\p*' token to test matching all the special characters w/o capture group. Note: the character '\\' is not captured by the token '\\p'.",
                "ignore_result": true,
                "__known_issue": "Link github issue ####",
                "pattern": "Special characters are \\p*",
                "log": "Special characters are $()|<\\",
                "end_match": "<\\",
                "captured_groups": []
            },
            {
                "description": "Using the '\\.+' token to test matching the character '\\' with capture group.",
                "pattern": "Backslash character is (\\.+)",
                "log": "Backslash character is \\",
                "end_match": "\\",
                "captured_groups": [
                    "\\"
                ]
            },
            {
                "description": "Using the '\\.+' token to test matching the character '\\' w/o capture group.",
                "pattern": "Backslash character is \\.+",
                "log": "Backslash character is \\",
                "end_match": "\\",
                "captured_groups": []
            },
            {
                "description": "Using the '\\.*' token to test matching the character '\\' with capture group.",
                "ignore_result": true,
                "__known_issue": "Link github issue ####",
                "pattern": "Backslash character is (\\.*)",
                "log": "Backslash character is \\",
                "end_match": "\\",
                "captured_groups": [
                    "\\"
                ]
            },
            {
                "description": "Using the '\\.*' token to test matching the character '\\' w/o capture group.",
                "ignore_result": true,
                "__known_issue": "Link github issue ####",
                "pattern": "Backslash character is \\.*",
                "log": "Backslash character is \\",
                "end_match": "\\",
                "captured_groups": []
            },
            {
                "description": "Using the '\\t+' token to test NOT matching all the special characters with capture group.",
                "ignore_result": true,
                "__known_issue": "Link github issue ####",
                "pattern": "Special characters are (\\t+)",
                "log": "Special characters are $()|<\\",
                "end_match": " $()|<\\",
                "captured_groups": [
                    ""
                ]
            },
            {
                "description": "Using the '\\t+' token to test NOT matching all the special characters w/o capture group.",
                "ignore_result": true,
                "__known_issue": "Link github issue ####",
                "pattern": "Special characters are \\t+",
                "log": "Special characters are $()|<\\",
                "end_match": " $()|<\\",
                "captured_groups": []
            },
            {
                "description": "Using the '\\t*' token to test NOT matching all the special characters with capture group.",
                "pattern": "Special characters are (\\t*)",
                "log": "Special characters are $()|<\\",
                "end_match": " $()|<\\",
                "captured_groups": [
                    ""
                ]
            },
            {
                "description": "Using the '\\t*' token to test NOT matching all the special characters w/o capture group.",
                "pattern": "Special characters are \\t*",
                "log": "Special characters are $()|<\\",
                "end_match": " $()|<\\",
                "captured_groups": []
            },
            {
                "description": "Using the '\\d+' token to test NOT matching all the special characters with capture group.",
                "ignore_result": true,
                "__known_issue": "Link github issue ####",
                "pattern": "Special characters are (\\d+)",
                "log": "Special characters are $()|<\\",
                "end_match": " $()|<\\",
                "captured_groups": [
                    ""
                ]
            },
            {
                "description": "Using the '\\d+' token to test NOT matching all the special characters w/o capture group.",
                "ignore_result": true,
                "__known_issue": "Link github issue ####",
                "pattern": "Special characters are \\d+",
                "log": "Special characters are $()|<\\",
                "end_match": " $()|<\\",
                "captured_groups": []
            },
            {
                "description": "Using the '\\d*' token to test NOT matching all the special characters with capture group.",
                "ignore_result": true,
                "__known_issue": "Link github issue ####",
                "pattern": "Special characters are (\\d*)",
                "log": "Special characters are $()|<\\",
                "end_match": " $()|<\\",
                "captured_groups": [
                    ""
                ]
            },
            {
                "description": "Using the '\\d*' token to test NOT matching all the special characters w/o capture group.",
                "ignore_result": true,
                "__known_issue": "Link github issue ####",
                "pattern": "Special characters are \\d*",
                "log": "Special characters are $()|<\\",
                "end_match": " $()|<\\",
                "captured_groups": []
            },
            {
                "description": "Using the '\\D+' token to test matching all the special characters with capture group.",
                "ignore_result": true,
                "__known_issue": "Link github issue ####",
                "pattern": "Special characters are (\\D+)",
                "log": "Special characters are $()|<\\",
                "end_match": "\\",
                "captured_groups": [
                    "$()|<\\"
                ]
            },
            {
                "description": "Using the '\\D+' token to test matching all the special characters w/o capture group.",
                "ignore_result": true,
                "__known_issue": "Link github issue ####",
                "pattern": "Special characters are \\D+",
                "log": "Special characters are $()|<\\",
                "end_match": "\\",
                "captured_groups": []
            },
            {
                "description": "Using the '\\D*' token to test matching all the special characters with capture group.",
                "ignore_result": true,
                "__known_issue": "Link github issue ####",
                "pattern": "Special characters are (\\D*)",
                "log": "Special characters are $()|<\\",
                "end_match": "\\",
                "captured_groups": [
                    "$()|<\\"
                ]
            },
            {
                "description": "Using the '\\D*' token to test matching all the special characters w/o capture group.",
                "ignore_result": true,
                "__known_issue": "Link github issue ####",
                "pattern": "Special characters are \\D*",
                "log": "Special characters are $()|<\\",
                "end_match": "\\",
                "captured_groups": []
            },
            {
                "description": "Using the '\\w+' token to test NOT matching all the special characters with capture group.",
                "ignore_result": true,
                "__known_issue": "Link github issue ####",
                "pattern": "Special characters are (\\w+)",
                "log": "Special characters are $()|<\\",
                "end_match": " $()|<\\",
                "captured_groups": [
                    ""
                ]
            },
            {
                "description": "Using the '\\w+' token to test NOT matching all the special characters w/o capture group.",
                "ignore_result": true,
                "__known_issue": "Link github issue ####",
                "pattern": "Special characters are \\w+",
                "log": "Special characters are $()|<\\",
                "end_match": " $()|<\\",
                "captured_groups": []
            },
            {
                "description": "Using the '\\w*' token to test NOT matching all the special characters with capture group.",
                "pattern": "Special characters are (\\w*)",
                "log": "Special characters are $()|<\\",
                "end_match": " $()|<\\",
                "captured_groups": [
                    ""
                ]
            },
            {
                "description": "Using the '\\w*' token to test NOT matching all the special characters w/o capture group.",
                "pattern": "Special characters are \\w*",
                "log": "Special characters are $()|<\\",
                "end_match": " $()|<\\",
                "captured_groups": []
            },
            {
                "description": "Using the '\\W+' token to test matching all the special characters with capture group.",
                "ignore_result": true,
                "__known_issue": "Link github issue ####",
                "pattern": "Special characters are (\\W+)",
                "log": "Special characters are $()|<\\",
                "end_match": "\\",
                "captured_groups": [
                    "$()|<\\"
                ]
            },
            {
                "description": "Using the '\\W+' token to test matching all the special characters w/o capture group.",
                "ignore_result": true,
                "__known_issue": "Link github issue ####",
                "pattern": "Special characters are \\W+",
                "log": "Special characters are $()|<\\",
                "end_match": "\\",
                "captured_groups": []
            },
            {
                "description": "Using the '\\W*' token to test matching all the special characters with capture group.",
                "ignore_result": true,
                "__known_issue": "Link github issue ####",
                "pattern": "Special characters are (\\W*)",
                "log": "Special characters are $()|<\\",
                "end_match": "\\",
                "captured_groups": [
                    "$()|<\\"
                ]
            },
            {
                "description": "Using the '\\W*' token to test matching all the special characters w/o capture group.",
                "ignore_result": true,
                "__known_issue": "Link github issue ####",
                "pattern": "Special characters are \\W*",
                "log": "Special characters are $()|<\\",
                "end_match": "\\",
                "captured_groups": []
            },
            {
                "description": "Using the '\\S+' token to test matching all the special characters with capture group.",
                "ignore_result": true,
                "__known_issue": "Link github issue ####",
                "pattern": "Special characters are (\\S+)",
                "log": "Special characters are $()|<\\",
                "end_match": "\\",
                "captured_groups": [
                    "$()|<\\"
                ]
            },
            {
                "description": "Using the '\\S+' token to test matching all the special characters w/o capture group.",
                "ignore_result": true,
                "__known_issue": "Link github issue ####",
                "pattern": "Special characters are \\S+",
                "log": "Special characters are $()|<\\",
                "end_match": "\\",
                "captured_groups": []
            },
            {
                "description": "Using the '\\S*' token to test matching all the special characters with capture group.",
                "ignore_result": true,
                "__known_issue": "Link github issue ####",
                "pattern": "Special characters are (\\S*)",
                "log": "Special characters are $()|<\\",
                "end_match": "\\",
                "captured_groups": [
                    "$()|<\\"
                ]
            },
            {
                "description": "Using the '\\S*' token to test matching all the special characters w/o capture group.",
                "ignore_result": true,
                "__known_issue": "Link github issue ####",
                "pattern": "Special characters are \\S*",
                "log": "Special characters are $()|<\\",
                "end_match": "\\",
                "captured_groups": []
            }
        ]
    },
    {
        "description": "[Functionality] Special characters. '^'",
        "batch_test": [
            {
                "description": "'^' test: Start of string without digits. Dont match",
                "pattern": "^(\\d+)",
                "log": "hi digits",
                "end_match": null,
                "captured_groups": []
            },
            {
                "description": "'^' test: Match without special caracter",
                "pattern": "\\d+^\\d\\d\\d",
                "ignore_result": false,
                "log": "123^456",
                "end_match": "6",
                "captured_groups": []
            },
            {
                "description": "'^' test: Start of string.",
                "ignore_result": true,
                "pattern": "^(\\d+)",
                "log": "1234",
                "end_match": "4",
                "captured_groups": []
            },
            {
                "description": "'^' test: Start of string.",
                "ignore_result": true,
                "pattern": "^(\\d+)",
                "log": "1234",
                "end_match": "4",
                "captured_groups": [
                    "1234"
                ]
            },
            {
                "description": "'^' test: Start of string.",
                "ignore_result": true,
                "pattern": "^\\d+",
                "log": "1234",
                "end_match": "4",
                "captured_groups": []
            },
            {
                "description": "'^' test: Start of string.",
                "ignore_result": true,
                "pattern": "^\\d+",
                "log": "1234",
                "end_match": "4",
                "captured_groups": []
            },
            {
                "description": "'^' test: Start of string.",
                "ignore_result": true,
                "pattern": "^(\\d+)",
                "log": "1234asd",
                "end_match": "4asd",
                "captured_groups": []
            },
            {
                "description": "'^' test: Start of string.",
                "ignore_result": true,
                "pattern": "^(\\d+)",
                "log": "1234asd",
                "end_match": "4asd",
                "captured_groups": [
                    "1234"
                ]
            },
            {
                "description": "'^' test: Start of string.",
                "ignore_result": true,
                "pattern": "^\\d+",
                "log": "1234asd",
                "end_match": "4",
                "captured_groups": []
            },
            {
                "description": "'^' test: Start of string.",
                "ignore_result": true,
                "pattern": "^\\d+",
                "log": "1234asd",
                "end_match": "4",
                "captured_groups": []
            }
        ]
    },
    {
        "description": "[Functionality] Special characters. '$'",
        "batch_test": [
            {
                "description": "'$' test: End of string. Without digits. Dont match",
                "pattern": "(\\d+)$",
                "log": "hi digits",
                "end_match": null,
                "captured_groups": []
            },
            {
                "description": "'$' test: Match without special caracter",
                "pattern": "\\d+$\\d\\d\\d",
                "log": "123$456",
                "end_match": "6",
                "captured_groups": []
            },
            {
                "description": "'$' test: end of string.",
                "pattern": "(\\d\\d\\d\\d)$",
                "log": "1234",
                "end_match": "4",
                "captured_groups": [
                    "1234"
                ]
            },
            {
                "description": "'$' test: Start of string.",
                "pattern": "(\\d\\d)$",
                "log": "1234",
                "end_match": "4",
                "captured_groups": [
                    "34"
                ]
            },
            {
                "description": "'^' test: Start of string.",
                "pattern": "\\d\\d\\d\\d$",
                "log": "1234",
                "end_match": "4",
                "captured_groups": []
            },
            {
                "description": "'^' test: Start of string.",
                "ignore_result": true,
                "pattern": "^\\d+",
                "log": "1234",
                "end_match": "4",
                "captured_groups": []
            },
            {
                "description": "'^' test: Start of string.",
                "ignore_result": true,
                "pattern": "^(\\d+)",
                "log": "1234asd",
                "end_match": "4asd",
                "captured_groups": []
            },
            {
                "description": "'^' test: Start of string.",
                "ignore_result": true,
                "pattern": "^(\\d+)",
                "log": "1234asd",
                "end_match": "4asd",
                "captured_groups": [
                    "1234"
                ]
            },
            {
                "description": "'$' test: End of string.",
                "pattern": "\\D\\D$",
                "log": "1234asd",
                "end_match": "d",
                "captured_groups": []
            },
            {
                "description": "'$' test: End of string.",
                "ignore_result": true,
                "pattern": "\\D\\D$",
                "log": "1234asd",
                "end_match": "d",
                "captured_groups": []
            }
        ]
    },
    {
        "description": "[Functionality] Combine special characters. ['^', '$']",
        "batch_test": [
            {
                "description": "Combine ^$ with non empty string",
                "pattern": "^$",
                "log": "hi digits",
                "end_match": null,
                "captured_groups": []
            },
            {
                "description": "Combine ^$ with empty string. Should be match",
                "pattern": "^$",
                "log": "",
                "end_match": "",
                "captured_groups": []
            },
            {
                "description": "Combine ^$ with empty string. Should be match, and obtain an empty group",
                "ignore_result": true,
                "pattern": "^()$",
                "log": "",
                "end_match": "",
                "captured_groups": [
                    ""
                ]
            },
            {
                "description": "Combine ^$ with non empty string",
                "pattern": "^$",
                "log": "hi digits",
                "end_match": null,
                "captured_groups": []
            },
            {
                "description": "Combine ^$ with empty string. Should be match",
                "pattern": "^$",
                "log": "",
                "end_match": "",
                "captured_groups": []
            },
            {
                "description": "Combine ^$ with empty string. Should be match, and obtain an empty group",
                "ignore_result": true,
                "pattern": "^()$",
                "log": "",
                "end_match": "",
                "captured_groups": [
                    ""
                ]
            }
        ]
    },
    {
        "description": "[Functionality] Special characters.  OR with flags ['^', '$','|']",
        "batch_test": [
            {
                "description": "Only last subpattern with capture groups",
                "ignore_result": true,
                "pattern": "^$|^\\d|\\d$|\\s(\\w+\\w)",
                "log": "^hi digits asd",
                "end_match": "s asd",
                "captured_groups": [
                    "digits"
                ]
            },
            {
                "description": "Nothing to match",
                "debug": true,
                "pattern": "^$|^\\d|\\d$|\\s(\\w+)",
                "log": "^hi*digits*asd$",
                "end_match": null,
                "captured_groups": []
            },
            {
                "description": "Only last subpattern with last",
                "ignore_result": true,
                "pattern": "^$|^\\d|\\d$|\\.+",
                "log": "^hi digits asd&",
                "end_match": "&",
                "captured_groups": []
            },
            {
                "description": "match with first",
                "pattern": "\\d\\d\\d\\d$|(\\d\\d\\d\\d)$",
                "log": "2020",
                "end_match": "0",
                "captured_groups": []
            }
        ]
    },
    {
        "description": "[Functionality] Corner cases. This tests have shown that OS Regex is not working as expected.",
        "batch_test": [
            {
                "description": "Last matched character pointed (end_match) should be '3' but it is '1'.",
                "__known_issue": "Matches but if the regex ends with a token with the quantifier '+' or '*', then it does not return the pointer to the last character matched, as it should be. BUG 3 of issue: https://github.com/wazuh/wazuh/issues/14420",
                "ignore_result": true,
                "pattern": "Pattern \\w+ \\d+",
                "log": "Pattern Wazuh 123",
                "end_match": "3",
                "captured_groups": []
            },
            {
                "description": "Last matched character pointed (end_match) should be '3' but it is '1'.",
                "__known_issue": "Matches but if the regex ends with a token with the quantifier '+' or '*', then it does not return the pointer to the last character matched, as it should be. BUG 3 of issue: https://github.com/wazuh/wazuh/issues/14420",
                "ignore_result": true,
                "pattern": "Pattern (\\w+ \\d+)",
                "log": "Pattern Wazuh 123",
                "end_match": "3",
                "captured_groups": [
                    "Wazuh 123"
                ]
            },
            {
                "description": "Last matched character pointed (end_match) should be '3' but it is '1'.",
                "__known_issue": "Matches but if the regex ends with a token with the quantifier '+' or '*', then it does not return the pointer to the last character matched, as it should be. BUG 3 of issue: https://github.com/wazuh/wazuh/issues/14420",
                "ignore_result": true,
                "pattern": "^Pattern \\w+ \\d+",
                "log": "Pattern Wazuh 123",
                "end_match": "3",
                "captured_groups": []
            },
            {
                "description": "Last matched character pointed (end_match) should be '3' but it is '1'.",
                "__known_issue": "Matches but if the regex ends with a token with the quantifier '+' or '*', then it does not return the pointer to the last character matched, as it should be. BUG 3 of issue: https://github.com/wazuh/wazuh/issues/14420",
                "ignore_result": true,
                "pattern": "^Pattern (\\w+ \\d+)",
                "log": "Pattern Wazuh 123",
                "end_match": "3",
                "captured_groups": [
                    "Wazuh 123"
                ]
            },
            {
                "description": "Last matched character pointed (end_match) should be '3' but it is '1'.",
                "__known_issue": "Matches but if the regex ends with a token with the quantifier '+' or '*', then it does not return the pointer to the last character matched, as it should be. BUG 3 of issue: https://github.com/wazuh/wazuh/issues/14420",
                "ignore_result": true,
                "pattern": "Pattern \\w+ \\d+$",
                "log": "Pattern Wazuh 123",
                "end_match": "3",
                "captured_groups": []
            },
            {
                "description": "Last matched character pointed (end_match) should be '3' but it is '1'.",
                "__known_issue": "Matches but if the regex ends with a token with the quantifier '+' or '*', then it does not return the pointer to the last character matched, as it should be. BUG 3 of issue: https://github.com/wazuh/wazuh/issues/14420",
                "ignore_result": true,
                "pattern": "Pattern (\\w+ \\d+)$",
                "log": "Pattern Wazuh 123",
                "end_match": "3",
                "captured_groups": [
                    "Wazuh 123"
                ]
            },
            {
                "description": "Last matched character pointed (end_match) should be '3' but it is ' ' (before the '1').",
                "__known_issue": "Matches but if the regex ends with a token with the quantifier '+' or '*', then it does not return the pointer to the last character matched, as it should be. BUG 3 of issue: https://github.com/wazuh/wazuh/issues/14420",
                "ignore_result": true,
                "pattern": "Pattern \\w* \\d*",
                "log": "Pattern Wazuh 123",
                "end_match": "3",
                "captured_groups": []
            },
            {
                "description": "Last matched character pointed (end_match) should be '3' but it is ' ' (before the '1').",
                "__known_issue": "Matches but if the regex ends with a token with the quantifier '+' or '*', then it does not return the pointer to the last character matched, as it should be. BUG 3 of issue: https://github.com/wazuh/wazuh/issues/14420",
                "ignore_result": true,
                "pattern": "Pattern (\\w* \\d*)",
                "log": "Pattern Wazuh 123",
                "end_match": "3",
                "captured_groups": [
                    "Wazuh 123"
                ]
            },
            {
                "description": "Last matched character pointed (end_match) should be '3' but it is ' ' (before the '1').",
                "__known_issue": "Matches but if the regex ends with a token with the quantifier '+' or '*', then it does not return the pointer to the last character matched, as it should be. BUG 3 of issue: https://github.com/wazuh/wazuh/issues/14420",
                "ignore_result": true,
                "pattern": "^Pattern \\w* \\d*",
                "log": "Pattern Wazuh 123",
                "end_match": "3",
                "captured_groups": []
            },
            {
                "description": "Last matched character pointed (end_match) should be '3' but it is ' ' (before the '1').",
                "__known_issue": "Matches but if the regex ends with a token with the quantifier '+' or '*', then it does not return the pointer to the last character matched, as it should be. BUG 3 of issue: https://github.com/wazuh/wazuh/issues/14420",
                "ignore_result": true,
                "pattern": "^Pattern (\\w* \\d*)",
                "log": "Pattern Wazuh 123",
                "end_match": "3",
                "captured_groups": [
                    "Wazuh 123"
                ]
            },
            {
                "description": "Last matched character pointed (end_match) should be '3' but it is ' ' (before the '1').",
                "__known_issue": "Matches but if the regex ends with a token with the quantifier '+' or '*', then it does not return the pointer to the last character matched, as it should be. BUG 3 of issue: https://github.com/wazuh/wazuh/issues/14420",
                "ignore_result": true,
                "pattern": "Pattern \\w* \\d*$",
                "log": "Pattern Wazuh 123",
                "end_match": "3",
                "captured_groups": []
            },
            {
                "description": "Last matched character pointed (end_match) should be '3' but it is ' ' (before the '1').",
                "__known_issue": "Matches but if the regex ends with a token with the quantifier '+' or '*', then it does not return the pointer to the last character matched, as it should be. BUG 3 of issue: https://github.com/wazuh/wazuh/issues/14420",
                "ignore_result": true,
                "pattern": "Pattern (\\w* \\d*)$",
                "log": "Pattern Wazuh 123",
                "end_match": "3",
                "captured_groups": [
                    "Wazuh 123"
                ]
            },
            {
                "description": "Last matched character pointed (end_match) should be '3' but it is '1'.",
                "__known_issue": "Matches but if the regex ends with a token with the quantifier '+' or '*', then it does not return the pointer to the last character matched, as it should be. BUG 3 of issue: https://github.com/wazuh/wazuh/issues/14420",
                "ignore_result": true,
                "pattern": "Subpattern 1: \\d+|Subpattern 2: \\d+",
                "log": "Subpattern 2: 123",
                "end_match": "3",
                "captured_groups": []
            },
            {
                "description": "Last matched character pointed (end_match) should be '3' but it is '1'.",
                "__known_issue": "Matches but if the regex ends with a token with the quantifier '+' or '*', then it does not return the pointer to the last character matched, as it should be. BUG 3 of issue: https://github.com/wazuh/wazuh/issues/14420",
                "ignore_result": true,
                "pattern": "Subpattern 1: \\d+|^Subpattern 2: \\d+",
                "log": "Subpattern 2: 123",
                "end_match": "3",
                "captured_groups": []
            },
            {
                "description": "Last matched character pointed (end_match) should be '3' but it is '1'.",
                "__known_issue": "Matches but if the regex ends with a token with the quantifier '+' or '*', then it does not return the pointer to the last character matched, as it should be. BUG 3 of issue: https://github.com/wazuh/wazuh/issues/14420",
                "ignore_result": true,
                "pattern": "Subpattern 1: \\d+|Subpattern 2: \\d+$",
                "log": "Subpattern 2: 123",
                "end_match": "3",
                "captured_groups": []
            },
            {
                "description": "Last matched character pointed (end_match) should be '3' but it is '1'.",
                "__known_issue": "Matches but if the regex ends with a token with the quantifier '+' or '*', then it does not return the pointer to the last character matched, as it should be. BUG 3 of issue: https://github.com/wazuh/wazuh/issues/14420",
                "ignore_result": true,
                "pattern": "Subpattern 1: (\\d+)|Subpattern 2: (\\d+)",
                "log": "Subpattern 2: 123",
                "end_match": "3",
                "captured_groups": [
                    "123"
                ]
            },
            {
                "description": "Last matched character pointed (end_match) should be '3' but it is '1'.",
                "__known_issue": "Matches but if the regex ends with a token with the quantifier '+' or '*', then it does not return the pointer to the last character matched, as it should be. BUG 3 of issue: https://github.com/wazuh/wazuh/issues/14420",
                "ignore_result": true,
                "pattern": "Subpattern 1: (\\d+)|^Subpattern 2: (\\d+)",
                "log": "Subpattern 2: 123",
                "end_match": "3",
                "captured_groups": [
                    "123"
                ]
            },
            {
                "description": "Last matched character pointed (end_match) should be '3' but it is '1'.",
                "__known_issue": "Matches but if the regex ends with a token with the quantifier '+' or '*', then it does not return the pointer to the last character matched, as it should be. BUG 3 of issue: https://github.com/wazuh/wazuh/issues/14420",
                "ignore_result": true,
                "pattern": "Subpattern 1: (\\d+)|Subpattern 2: (\\d+)$",
                "log": "Subpattern 2: 123",
                "end_match": "3",
                "captured_groups": [
                    "123"
                ]
            },
            {
                "description": "Last matched character pointed (end_match) should be '3' but it is 's' (After '3').",
                "__known_issue": "Matches but if the regex ends with a token with the quantifier '+' or '*', then it does not return the pointer to the last character matched, as it should be. BUG 3 of issue: https://github.com/wazuh/wazuh/issues/14420",
                "ignore_result": true,
                "pattern": "\\d+",
                "log": "123subpattern",
                "end_match": "3subpattern",
                "captured_groups": []
            },
            {
                "description": "Last matched character pointed (end_match) should be '3' but it is '1'.",
                "__known_issue": "Matches but if the regex ends with a token with the quantifier '+' or '*', then it does not return the pointer to the last character matched, as it should be. BUG 3 of issue: https://github.com/wazuh/wazuh/issues/14420",
                "ignore_result": true,
                "pattern": "\\d+",
                "log": "subpattern123",
                "end_match": "3",
                "captured_groups": []
            },
            {
                "description": "Last matched character pointed (end_match) should be '3' but it is '1'.",
                "__known_issue": "Matches but if the regex ends with a token with the quantifier '+' or '*', then it does not return the pointer to the last character matched, as it should be. BUG 3 of issue: https://github.com/wazuh/wazuh/issues/14420",
                "ignore_result": true,
                "pattern": "\\d+",
                "log": "123",
                "end_match": "3",
                "captured_groups": []
            },
            {
                "description": "Last matched character pointed (end_match) should be '9' but it is '1'.",
                "__known_issue": "Matches but if the regex ends with a token with the quantifier '+' or '*', then it does not return the pointer to the last character matched, as it should be. BUG 3 of issue: https://github.com/wazuh/wazuh/issues/14420",
                "ignore_result": true,
                "pattern": "\\d+",
                "log": "123456789",
                "end_match": "9",
                "captured_groups": []
            },
            {
                "description": "This case works well.",
                "pattern": "\\d+",
                "log": "1",
                "end_match": "1",
                "captured_groups": []
            },
            {
                "description": "Last matched character pointed (end_match) should be '3' but it is '1'.",
                "__known_issue": "Matches but if the regex ends with a token with the quantifier '+' or '*', then it does not return the pointer to the last character matched, as it should be. BUG 3 of issue: https://github.com/wazuh/wazuh/issues/14420",
                "ignore_result": true,
                "pattern": "(\\d+)",
                "log": "123",
                "end_match": "3",
                "captured_groups": [
                    "123"
                ]
            },
            {
                "description": "Last matched character pointed (end_match) should be '3' but it is '1'.",
                "__known_issue": "Matches but if the regex ends with a token with the quantifier '+' or '*', then it does not return the pointer to the last character matched, as it should be. BUG 3 of issue: https://github.com/wazuh/wazuh/issues/14420",
                "ignore_result": true,
                "pattern": "(\\d+)",
                "log": "123subpattern",
                "end_match": "3subpattern",
                "captured_groups": [
                    "123"
                ]
            },
            {
                "description": "Last matched character pointed (end_match) should be '3' but it is '1'.",
                "__known_issue": "Matches but if the regex ends with a token with the quantifier '+' or '*', then it does not return the pointer to the last character matched, as it should be. BUG 3 of issue: https://github.com/wazuh/wazuh/issues/14420",
                "ignore_result": true,
                "pattern": "(\\d+)",
                "log": "subpattern123",
                "end_match": "3",
                "captured_groups": [
                    "123"
                ]
            },
            {
                "description": "Last matched character pointed (end_match) should be '9' but it is '1'.",
                "__known_issue": "Matches but if the regex ends with a token with the quantifier '+' or '*', then it does not return the pointer to the last character matched, as it should be. BUG 3 of issue: https://github.com/wazuh/wazuh/issues/14420",
                "ignore_result": true,
                "pattern": "(\\d+)",
                "log": "123456789",
                "end_match": "9",
                "captured_groups": [
                    "123456789"
                ]
            },
            {
                "description": "This case works well.",
                "pattern": "(\\d+)",
                "log": "1",
                "end_match": "1",
                "captured_groups": [
                    "1"
                ]
            },
            {
                "description": "Last matched character pointed (end_match) should be '3' but it is 's' (After '3').",
                "__known_issue": "Matches but if the regex ends with a token with the quantifier '+' or '*', then it does not return the pointer to the last character matched, as it should be. BUG 3 of issue: https://github.com/wazuh/wazuh/issues/14420",
                "ignore_result": true,
                "pattern": "\\d*",
                "log": "123",
                "end_match": "3",
                "captured_groups": []
            },
            {
                "description": "Last matched character pointed (end_match) should be '3' but it is 's' (After '3').",
                "__known_issue": "Matches but if the regex ends with a token with the quantifier '+' or '*', then it does not return the pointer to the last character matched, as it should be. BUG 3 of issue: https://github.com/wazuh/wazuh/issues/14420",
                "ignore_result": true,
                "pattern": "\\d*",
                "log": "123subpattern",
                "end_match": "3subpattern",
                "captured_groups": []
            },
            {
                "description": "This test overflows the heap buffer.",
                "__known_issue": "When the regex consists only of tokens with '*' quantifiers, then it always matches. When it matches having 0 matching characters, then it returns the pointer poiting to one byte before the beginning of the string. BUG Issue: https://github.com/Wazuh/Wazuh/issues/14249",
                "skip_test": true,
                "pattern": "\\d*",
                "log": "subpattern123",
                "end_match": "3",
                "captured_groups": []
            },
            {
                "description": "Last matched character pointed (end_match) should be '3' but it is '1'.",
                "__known_issue": "Matches but if the regex ends with a token with the quantifier '+' or '*', then it does not return the pointer to the last character matched, as it should be. BUG 3 of issue: https://github.com/wazuh/wazuh/issues/14420",
                "ignore_result": true,
                "pattern": "(\\d*)",
                "log": "123",
                "end_match": "3",
                "captured_groups": [
                    "123"
                ]
            },
            {
                "description": "With capture group the case works well.",
                "pattern": "(\\d*)",
                "log": "123subpattern",
                "end_match": "3subpattern",
                "captured_groups": [
                    "123"
                ]
            },
            {
                "description": "This test overflows the heap buffer.",
                "__known_issue": "When the regex consists only of tokens with '*' quantifiers, then it always matches. When it matches having 0 matching characters, then it returns the pointer poiting to one byte before the beginning of the string. BUG Issue: https://github.com/Wazuh/Wazuh/issues/14249",
                "skip_test": true,
                "pattern": "(\\d*)",
                "log": "subpattern123",
                "end_match": "subpattern123",
                "captured_groups": [
                    ""
                ]
            },
            {
                "description": "Last matched character pointed (end_match) should be '3' but it is '1'.",
                "__known_issue": "Matches but if the regex ends with a token with the quantifier '+' or '*', then it does not return the pointer to the last character matched, as it should be. BUG 3 of issue: https://github.com/wazuh/wazuh/issues/14420",
                "ignore_result": true,
                "pattern": "^\\d+",
                "log": "123",
                "end_match": "3",
                "captured_groups": []
            },
            {
                "description": "Last matched character pointed (end_match) should be '3' but it is 's' (After '3').",
                "__known_issue": "Matches but if the regex ends with a token with the quantifier '+' or '*', then it does not return the pointer to the last character matched, as it should be. BUG 3 of issue: https://github.com/wazuh/wazuh/issues/14420",
                "ignore_result": true,
                "pattern": "^\\d+",
                "log": "123subpattern",
                "end_match": "3subpattern",
                "captured_groups": []
            },
            {
                "description": "This test passes.",
                "pattern": "^\\d+",
                "log": "subpattern123",
                "end_match": null,
                "captured_groups": []
            },
            {
                "description": "Last matched character pointed (end_match) should be '3' but it is '1'.",
                "__known_issue": "Matches but if the regex ends with a token with the quantifier '+' or '*', then it does not return the pointer to the last character matched, as it should be. BUG 3 of issue: https://github.com/wazuh/wazuh/issues/14420",
                "ignore_result": true,
                "pattern": "^(\\d+)",
                "log": "123",
                "end_match": "3",
                "captured_groups": [
                    "123"
                ]
            },
            {
                "description": "Last matched character pointed (end_match) should be '3' but it is '1'.",
                "__known_issue": "Matches but if the regex ends with a token with the quantifier '+' or '*', then it does not return the pointer to the last character matched, as it should be. BUG 3 of issue: https://github.com/wazuh/wazuh/issues/14420",
                "ignore_result": true,
                "pattern": "^(\\d+)",
                "log": "123subpattern",
                "end_match": "3subpattern",
                "captured_groups": [
                    "123"
                ]
            },
            {
                "description": "This test passes.",
                "pattern": "^(\\d+)",
                "log": "subpattern123",
                "end_match": null,
                "captured_groups": []
            },
            {
                "description": "Last matched character pointed (end_match) should be '3' but it is '1'.",
                "__known_issue": "Matches but if the regex ends with a token with the quantifier '+' or '*', then it does not return the pointer to the last character matched, as it should be. BUG 3 of issue: https://github.com/wazuh/wazuh/issues/14420",
                "ignore_result": true,
                "pattern": "^\\d*",
                "log": "123",
                "end_match": "3",
                "captured_groups": []
            },
            {
                "description": "Last matched character pointed (end_match) should be '3' but it is 's' (After '3').",
                "ignore_result": true,
                "__known_issue": "Matches but if the regex ends with a token with the quantifier '+' or '*', then it does not return the pointer to the last character matched, as it should be. BUG 3 of issue: https://github.com/wazuh/wazuh/issues/14420",
                "pattern": "^\\d*",
                "log": "123subpattern",
                "end_match": "3subpattern",
                "captured_groups": []
            },
            {
                "description": "This test overflows the heap buffer.",
                "__known_issue": "When the regex consists only of tokens with '*' quantifiers, then it always matches. When it matches having 0 matching characters, then it returns the pointer poiting to one byte before the beginning of the string. BUG Issue: https://github.com/Wazuh/Wazuh/issues/14249",
                "skip_test": true,
                "pattern": "^\\d*",
                "log": "subpattern123",
                "end_match": null,
                "captured_groups": []
            },
            {
                "description": "Last matched character pointed (end_match) should be '3' but it is '1'.",
                "ignore_result": true,
                "__known_issue": "Matches but if the regex ends with a token with the quantifier '+' or '*', then it does not return the pointer to the last character matched, as it should be. BUG 3 of issue: https://github.com/wazuh/wazuh/issues/14420",
                "pattern": "^(\\d*)",
                "log": "123",
                "end_match": "3",
                "captured_groups": [
                    "123"
                ]
            },
            {
                "description": "With capture group the case works well.",
                "pattern": "^(\\d*)",
                "log": "123subpattern",
                "end_match": "3subpattern",
                "captured_groups": [
                    "123"
                ]
            },
            {
                "description": "This test overflows the heap buffer.",
                "skip_test": true,
                "__known_issue": "When the regex consists only of tokens with '*' quantifiers, then it always matches. When it matches having 0 matching characters, then it returns the pointer poiting to one byte before the beginning of the string. BUG Issue: https://github.com/Wazuh/Wazuh/issues/14249",
                "pattern": "^(\\d*)",
                "log": "subpattern123",
                "end_match": null,
                "captured_groups": [
                    ""
                ]
            },
            {
                "description": "Last matched character pointed (end_match) should be '3' but it is '1'.",
                "__known_issue": "Matches but if the regex ends with a token with the quantifier '+' or '*', then it does not return the pointer to the last character matched, as it should be. BUG 3 of issue: https://github.com/wazuh/wazuh/issues/14420",
                "ignore_result": true,
                "pattern": "\\d+$",
                "log": "123",
                "end_match": "3",
                "captured_groups": []
            },
            {
                "description": "Last matched character pointed (end_match) should be '3' but it is '1'.",
                "__known_issue": "Matches but if the regex ends with a token with the quantifier '+' or '*', then it does not return the pointer to the last character matched, as it should be. BUG 3 of issue: https://github.com/wazuh/wazuh/issues/14420",
                "ignore_result": true,
                "pattern": "\\d+$",
                "log": "log123",
                "end_match": "3",
                "captured_groups": []
            },
            {
                "description": "Last matched character pointed (end_match) should be '3' but it is '1'.",
                "__known_issue": "Matches but if the regex ends with a token with the quantifier '+' or '*', then it does not return the pointer to the last character matched, as it should be. BUG 3 of issue: https://github.com/wazuh/wazuh/issues/14420",
                "ignore_result": true,
                "pattern": "(\\d+)$",
                "log": "123",
                "end_match": "3",
                "captured_groups": [
                    "123"
                ]
            },
            {
                "description": "Last matched character pointed (end_match) should be '3' but it is '1'.",
                "__known_issue": "Matches but if the regex ends with a token with the quantifier '+' or '*', then it does not return the pointer to the last character matched, as it should be. BUG 3 of issue: https://github.com/wazuh/wazuh/issues/14420",
                "ignore_result": true,
                "pattern": "(\\d+)$",
                "log": "log123",
                "end_match": "3",
                "captured_groups": [
                    "123"
                ]
            },
            {
                "description": "Last matched character pointed (end_match) should be '3' but it is '1'.",
                "__known_issue": "Matches but if the regex ends with a token with the quantifier '+' or '*', then it does not return the pointer to the last character matched, as it should be. BUG 3 of issue: https://github.com/wazuh/wazuh/issues/14420",
                "ignore_result": true,
                "pattern": "\\d*$",
                "log": "123",
                "end_match": "3",
                "captured_groups": []
            },
            {
                "description": "It should match but it doesn't.",
                "ignore_result": true,
                "pattern": "\\d*$",
                "log": "pattern123",
                "end_match": "3",
                "captured_groups": []
            },
            {
                "description": "This test passes.",
                "pattern": "\\d*$",
                "log": "123pattern",
                "end_match": null,
                "captured_groups": []
            },
            {
                "description": "Last matched character pointed (end_match) should be '3' but it is '1'.",
                "ignore_result": true,
                "pattern": "(\\d*)$",
                "log": "123",
                "end_match": "3",
                "captured_groups": [
                    "123"
                ]
            },
            {
                "description": "It should match but it doesn't.",
                "__known_issue": "When the regex is a backlashed token with the '*' quantifier follow by the flag '$' (end of string) and the string does not start with a character that belongs to the character map of such a token, then it does not match as expected. BUG 7 of issue: https://github.com/wazuh/wazuh/issues/14420",
                "ignore_result": true,
                "pattern": "(\\d*)$",
                "log": "pattern123",
                "end_match": "3",
                "captured_groups": [
                    "123"
                ]
            },
            {
                "description": "This test passes.",
                "__known_issue": "When the regex is a backlashed token with the '*' quantifier follow by the flag '$' (end of string) and the string does not start with a character that belongs to the character map of such a token, then it does not match as expected. BUG 7 of issue: https://github.com/wazuh/wazuh/issues/14420",
                "ignore_result": true,
                "pattern": "(\\d*)$",
                "log": "123pattern",
                "end_match": "",
                "captured_groups": [
                    ""
                ]
            },
            {
                "description": "Consecutive capture groups (without something in between) do not match when should.",
                "__known_issue": "It should match but does not, adjacent capture groups are not supported. BUG 1 of issue: https://github.com/wazuh/wazuh/issues/14420",
                "ignore_result": true,
                "pattern": "(\\D+)(\\d+)",
                "log": "Test123",
                "end_match": "3",
                "captured_groups": [
                    "Test",
                    "123"
                ]
            },
            {
                "description": "Consecutive capture groups (without something in between) do not match.",
                "__known_issue": "It should match but does not, adjacent capture groups are not supported. BUG 1 of issue: https://github.com/wazuh/wazuh/issues/14420",
                "ignore_result": true,
                "pattern": "(\\d+)(\\D+)",
                "log": "123Test",
                "end_match": "t",
                "captured_groups": [
                    "123",
                    "Test"
                ]
            },
            {
                "description": "Consecutive capture groups (without something in between) do not match.",
                "__known_issue": "It should match but does not, adjacent capture groups are not supported. BUG 1 of issue: https://github.com/wazuh/wazuh/issues/14420",
                "ignore_result": true,
                "pattern": "(\\D*)(\\d*)",
                "log": "Test123",
                "end_match": "3",
                "captured_groups": [
                    "Test",
                    "123"
                ]
            },
            {
                "description": "Consecutive capture groups (without something in between) do not match.",
                "__known_issue": "It should match but does not, adjacent capture groups are not supported. BUG 1 of issue: https://github.com/wazuh/wazuh/issues/14420",
                "ignore_result": true,
                "pattern": "(\\d*)(\\D*)",
                "log": "123Test",
                "end_match": "t",
                "captured_groups": [
                    "123",
                    "Test"
                ]
            },
            {
                "description": "Last matched character pointed (end_match) should be '3' but it is '1'.",
                "__known_issue": "Matches but if the regex ends with a token with the quantifier '+' or '*', then it does not return the pointer to the last character matched, as it should be. BUG 3 of issue: https://github.com/wazuh/wazuh/issues/14420",
                "ignore_result": true,
                "pattern": "\\D+\\d+",
                "log": "Test123",
                "end_match": "3",
                "captured_groups": []
            },
            {
                "description": "Last matched character pointed (end_match) should be 't' but it is 'T'.",
                "__known_issue": "Matches but if the regex ends with a token with the quantifier '+' or '*', then it does not return the pointer to the last character matched, as it should be. BUG 3 of issue: https://github.com/wazuh/wazuh/issues/14420",
                "ignore_result": true,
                "pattern": "\\d+\\D+",
                "log": "123Test",
                "end_match": "t",
                "captured_groups": []
            },
            {
                "description": "Last matched character pointed (end_match) should be '3' but it is 't'.",
                "__known_issue": "Matches but if the regex ends with a token with the quantifier '+' or '*', then it does not return the pointer to the last character matched, as it should be. BUG 3 of issue: https://github.com/wazuh/wazuh/issues/14420",
                "ignore_result": true,
                "pattern": "\\D*\\d*",
                "log": "Test123",
                "end_match": "3",
                "captured_groups": []
            },
            {
                "description": "Last matched character pointed (end_match) should be 't' but it is '3'.",
                "__known_issue": "Matches but if the regex ends with a token with the quantifier '+' or '*', then it does not return the pointer to the last character matched, as it should be. BUG 3 of issue: https://github.com/wazuh/wazuh/issues/14420",
                "ignore_result": true,
                "pattern": "\\d*\\D*",
                "log": "123Test",
                "end_match": "t",
                "captured_groups": []
            },
            {
                "description": "Tokens with optional quantifier (*) should always match, but they don't.",
                "__known_issue": "When there are 4 more optional tokens than characters to match, the regex doesn't match. BUG 8 of issue: https://github.com/wazuh/wazuh/issues/14420",
                "ignore_result": true,
                "pattern": "\\w*\\w*\\w*\\w*\\w*\\w*",
                "log": "xy",
                "end_match": "y",
                "captured_groups": []
            },
            {
                "description": "Tokens with optional quantifier (*) should always match, but they don't.",
                "__known_issue": "In this case, with extra optional tokens inside a capture group, it does match.",
                "pattern": "(\\w*\\d*\\w*\\d*\\w*\\d*)",
                "log": "xy",
                "end_match": "y",
                "captured_groups": [
                    "xy"
                ]
            },
            {
                "description": "Tokens with optional quantifier (*) should always match, but they don't.",
                "__known_issue": "In this case, with extra optional tokens inside a capture group, it does match.",
                "pattern": "^(\\w*\\d*\\w*\\d*\\w*\\d*)",
                "log": "xy",
                "end_match": "y",
                "captured_groups": [
                    "xy"
                ]
            },
            {
                "description": "Tokens with optional quantifier (*) should always match, but they don't.",
                "__known_issue": "In this case, with extra optional tokens inside a capture group, it does match.",
                "pattern": "(\\w*\\d*\\w*\\d*\\w*\\d*)$",
                "log": "xy",
                "end_match": "y",
                "captured_groups": [
                    "xy"
                ]
            },
            {
                "description": "Tokens with optional quantifier (*) should always match, but they don't.",
                "__known_issue": "In this case, with 10 extra optional tokens inside a capture group, it does match.",
                "pattern": "(\\w*\\w*\\w*\\w*\\w*\\w*\\w*\\w*\\w*\\w*\\w*\\w*)",
                "log": "xy",
                "end_match": "y",
                "captured_groups": [
                    "xy"
                ]
            },
            {
                "description": "Tokens with optional quantifier (*) should always match, but they don't.",
                "__known_issue": "In this case, with 10 extra optional tokens inside a capture group, it does match.",
                "pattern": "^(\\w*\\w*\\w*\\w*\\w*\\w*\\w*\\w*\\w*\\w*\\w*\\w*)",
                "log": "xy",
                "end_match": "y",
                "captured_groups": [
                    "xy"
                ]
            },
            {
                "description": "Tokens with optional quantifier (*) should always match, but they don't.",
                "__known_issue": "In this case, with 10 extra optional tokens inside a capture group, it does match.",
                "pattern": "(\\w*\\w*\\w*\\w*\\w*\\w*\\w*\\w*\\w*\\w*\\w*\\w*)$",
                "log": "xy",
                "end_match": "y",
                "captured_groups": [
                    "xy"
                ]
            },
            {
                "description": "Tokens with optional quantifier (*) should always match, but they don't.",
                "__known_issue": "With 3 optional tokens do not match that do not mach, it does NOT match.",
                "ignore_result": true,
                "pattern": "\\w*\\p*\\d*\\w*",
                "log": "xy",
                "end_match": "y",
                "captured_groups": []
            },
            {
                "description": "Tokens with optional quantifier (*) should always match, but they don't.",
                "__known_issue": "When there are 3 tokens with the quantifier '*' consecutively, under certain circumstances, the regex does not match even though it should. BUG 8 of issue: https://github.com/wazuh/wazuh/issues/14420",
                "ignore_result": true,
                "pattern": "\\w*\\p*\\d*\\w*",
                "log": "xy55",
                "end_match": "5",
                "captured_groups": []
            },
            {
                "description": "Tokens with optional quantifier (*) should always match, but they don't.",
                "__known_issue": "When there are 3 tokens with the quantifier '*' consecutively, under certain circumstances, the regex does not match even though it should. BUG 8 of issue: https://github.com/wazuh/wazuh/issues/14420",
                "ignore_result": true,
                "pattern": "\\w+\\p*\\d*\\w*",
                "log": "xy55",
                "end_match": "5",
                "captured_groups": []
            },
            {
                "description": "Tokens with optional quantifier (*) should always match, but they don't.",
                "pattern": "(\\w*)\\p*\\d*\\w*",
                "log": "xy",
                "end_match": "y",
                "captured_groups": [
                    "xy"
                ]
            },
            {
                "description": "Tokens with optional quantifier (*) should always match, but they don't.",
                "__known_issue": "When there are 3 tokens with the quantifier '*' consecutively, under certain circumstances, the regex does not match even though it should. BUG 8 of issue: https://github.com/wazuh/wazuh/issues/14420",
                "ignore_result": true,
                "pattern": "^\\w*\\p*\\d*\\w*",
                "log": "xy",
                "end_match": "y",
                "captured_groups": []
            },
            {
                "description": "Tokens with optional quantifier (*) should always match, but they don't.",
                "__known_issue": "When there are 3 tokens with the quantifier '*' consecutively, under certain circumstances, the regex does not match even though it should. BUG 8 of issue: https://github.com/wazuh/wazuh/issues/14420",
                "ignore_result": true,
                "pattern": "\\w*\\p*\\d*\\w*$",
                "log": "xy",
                "end_match": "y",
                "captured_groups": []
            },
            {
                "description": "Tokens with optional quantifier (*) should always match, but they don't.",
                "__known_issue": "In this case, with 3 extra optional tokens inside a capture group, it does match.",
                "pattern": "(\\w*\\p*\\d*\\w*)",
                "log": "xy",
                "end_match": "y",
                "captured_groups": [
                    "xy"
                ]
            },
            {
                "description": "Tokens with optional quantifier (*) should always match, but they don't.",
                "__known_issue": "In this case, with 3 extra optional tokens, it does NOT match.",
                "ignore_result": true,
                "pattern": "\\w*\\d*\\w*\\p*",
                "log": "xy",
                "end_match": "y",
                "captured_groups": []
            },
            {
                "description": "Tokens with optional quantifier (*) should always match, but they don't.",
                "__known_issue": "In this case, with 2 extra optional tokens, it does match.",
                "pattern": "\\w*\\d*\\w*",
                "log": "xy",
                "end_match": "y",
                "captured_groups": []
            },
            {
                "description": "Tokens with optional quantifier (*) should always match, but they don't.",
                "__known_issue": "In this case, with 2 extra optional tokens, it does match.",
                "pattern": "^\\w*\\d*\\w*",
                "log": "xy",
                "end_match": "y",
                "captured_groups": []
            },
            {
                "description": "Tokens with optional quantifier (*) should always match, but they don't.",
                "__known_issue": "In this case, with 2 extra optional tokens, it does match.",
                "pattern": "\\w*\\d*\\w*$",
                "log": "xy",
                "end_match": "y",
                "captured_groups": []
            },
            {
                "description": "Tokens with optional quantifier (*) should always match, but they don't.",
                "__known_issue": "When there are 3 tokens with the quantifier '*' consecutively, under certain circumstances, the regex does not match even though it should. BUG 8 of issue: https://github.com/wazuh/wazuh/issues/14420",
                "ignore_result": true,
                "pattern": "\\w*\\d*\\p*\\w*",
                "log": "xy",
                "end_match": "y",
                "captured_groups": []
            },
            {
                "description": "Tokens with optional quantifier (*) should always match, but they don't.",
                "__known_issue": "In this case, with only 3 extra optional tokens, it does match.",
                "pattern": "\\w*\\w*\\w*\\w*\\w*",
                "log": "xy",
                "end_match": "y",
                "captured_groups": []
            },
            {
                "description": "Tokens with optional quantifier (*) should always match, but they don't.",
                "__known_issue": "Maybe related with bug 9 or 8. BUG 10 of issue: https://github.com/wazuh/wazuh/issues/14420",
                "__known_issue_2": "In this case there are 2 exceding optional tokens, the regex doesn't match.",
                "ignore_result": true,
                "pattern": "xyz\\d*\\w*",
                "log": "xyz",
                "end_match": "z",
                "captured_groups": []
            },
            {
                "description": "Tokens with optional quantifier (*) should always match, but they don't.",
                "__known_issue": "Maybe related with bug 9 or 8. BUG 10 of issue: https://github.com/wazuh/wazuh/issues/14420",
                "__known_issue_2": "In this case there are 2 exceding optional tokens inside a capture groupe, the regex doesn't match.",
                "ignore_result": true,
                "pattern": "xyz(\\d*\\w*)",
                "log": "xyz",
                "end_match": "z",
                "captured_groups": [
                    ""
                ]
            },
            {
                "description": "Tokens with optional quantifier (*) should always match, but they don't.",
                "__known_issue": "May related with bug 5. BUG 11 of issue: https://github.com/wazuh/wazuh/issues/14420",
                "__known_issue_2": "In this case there is 1 exceding optional token inside a capture groupe, the regex does match but the expected group is not captured.",
                "ignore_result": true,
                "pattern": "xyz(\\w*)",
                "log": "xyz",
                "end_match": "z",
                "captured_groups": [
                    ""
                ]
            },
            {
                "description": "Tokens with optional quantifier (*) should always match, but they don't.",
                "__known_issue": "In this case there are 2 exceding optional tokens inside a capture groupe, the regex doesn't match.",
                "pattern": "xyz(\\w*)",
                "log": "xyz ",
                "end_match": "z ",
                "captured_groups": [
                    ""
                ]
            },
            {
                "description": "Tokens with optional quantifier (*) should always match, but they don't.",
                "__known_issue": "In this case there are 2 exceding optional tokens inside a capture groupe, the regex doesn't match.",
                "__known_issue": "May related with bug 5. BUG 11 of issue: https://github.com/wazuh/wazuh/issues/14420",
                "ignore_result": true,
                "pattern": "xyz\\w*(\\w*)",
                "log": "xyz",
                "end_match": "z",
                "captured_groups": [
                    ""
                ]
            },
            {
                "description": "Tokens with optional quantifier (*) should always match, but they don't.",
                "__known_issue": "In this case the regex does match.",
                "pattern": "(xyz\\w*\\w*)",
                "log": "xyz",
                "end_match": "z",
                "captured_groups": [
                    "xyz"
                ]
            },
            {
                "description": "Tokens with optional quantifier (*) should always match, but they don't.",
                "__known_issue": "In this case the regex does match.",
                "pattern": "\\d+\\w*\\w*",
                "log": "123",
                "end_match": "3",
                "captured_groups": []
            },
            {
                "description": "Capture group is not correctly obtained. It should be '123' but it is empty.",
                "ignore_result": true,
                "__known_issue": "BUG 12 of issue: https://github.com/wazuh/wazuh/issues/14420",
                "pattern": "(\\d+)\\D*",
                "log": "123",
                "end_match": "3",
                "captured_groups": [
                    "123"
                ]
            },
            {
                "description": "This case matches.",
                "pattern": "(\\d+)\\D* ",
                "log": "123 ",
                "end_match": " ",
                "captured_groups": [
                    "123"
                ]
            },
            {
                "description": "Last matched character pointed (end_match) should be 't' but it is '3'.",
                "__known_issue": "Matches but if the regex ends with a token with the quantifier '+' or '*', then it does not return the pointer to the last character matched, as it should be. BUG 3 of issue: https://github.com/wazuh/wazuh/issues/14420",
                "ignore_result": true,
                "pattern": "(\\d+)\\D*",
                "log": "123Test",
                "end_match": "t",
                "captured_groups": [
                    "123"
                ]
            },
            {
                "description": "Capture group is not correctly obtained. It should be '123' but it is empty.",
                "__known_issue": "BUG 12 of issue: https://github.com/wazuh/wazuh/issues/14420",
                "ignore_result": true,
                "pattern": "(\\d+)\\D*",
                "log": "Test123",
                "end_match": "3",
                "captured_groups": [
                    "123"
                ]
            },
            {
                "description": "Capture group is not correctly obtained. It should be an empty group but it is null.",
                "__known_issue": "BUG 12 of issue: https://github.com/wazuh/wazuh/issues/14420",
                "ignore_result": true,
                "pattern": "\\d+(\\D*)",
                "log": "123",
                "end_match": "3",
                "captured_groups": [
                    ""
                ]
            },
            {
                "description": "Last matched character pointed (end_match) should be 't' but it is '3'.",
                "ignore_result": true,
                "__known_issue": "Matches but if the regex ends with a token with the quantifier '+' or '*', then it does not return the pointer to the last character matched, as it should be. BUG 3 of issue: https://github.com/wazuh/wazuh/issues/14420",
                "pattern": "\\d+(\\D*)",
                "log": "123Test",
                "end_match": "t",
                "captured_groups": [
                    "Test"
                ]
            },
            {
                "description": "Capture group is not correctly obtained. It should be an empty group but it is null.",
                "__known_issue": "BUG 12 of issue: https://github.com/wazuh/wazuh/issues/14420",
                "ignore_result": true,
                "pattern": "\\d+(\\D*)",
                "log": "Test123",
                "end_match": "3",
                "captured_groups": [
                    ""
                ]
            },
            {
                "description": "Capture group is not correctly obtained. It should be an empty group but it is null.",
                "ignore_result": true,
                "__known_issue": "BUG 12 of issue: https://github.com/wazuh/wazuh/issues/14420",
                "pattern": "^\\d+(\\D*)",
                "log": "123",
                "end_match": "3",
                "captured_groups": [
                    ""
                ]
            },
            {
                "description": "Last matched character pointed (end_match) should be 't' but it is '3'.",
                "ignore_result": true,
                "__known_issue": "Matches but if the regex ends with a token with the quantifier '+' or '*', then it does not return the pointer to the last character matched, as it should be. BUG 3 of issue: https://github.com/wazuh/wazuh/issues/14420",
                "pattern": "^\\d+(\\D*)",
                "log": "123Test",
                "end_match": "t",
                "captured_groups": [
                    "Test"
                ]
            },
            {
                "description": "This test passes.",
                "pattern": "^\\d+(\\D*)",
                "log": "Test123",
                "end_match": null,
                "captured_groups": [
                    ""
                ]
            },
            {
                "description": "Capture group is not correctly obtained. It should be an empty group but it is null.",
                "__known_issue": "BUG 12 of issue: https://github.com/wazuh/wazuh/issues/14420",
                "ignore_result": true,
                "pattern": "^(\\d+)\\D*",
                "log": "123",
                "end_match": "3",
                "captured_groups": [
                    "123"
                ]
            },
            {
                "description": "Last matched character pointed (end_match) should be 't' but it is '3'.",
                "__known_issue": "Matches but if the regex ends with a token with the quantifier '+' or '*', then it does not return the pointer to the last character matched, as it should be. BUG 3 of issue: https://github.com/wazuh/wazuh/issues/14420",
                "ignore_result": true,
                "pattern": "^(\\d+)\\D*",
                "log": "123Test",
                "end_match": "t",
                "captured_groups": [
                    "123"
                ]
            },
            {
                "description": "This test passes.",
                "pattern": "^(\\d+)\\D*",
                "log": "Test123",
                "end_match": null,
                "captured_groups": [
                    ""
                ]
            },
            {
                "description": "Capture group is not correctly obtained. It should be an empty group but it is null.",
                "__known_issue": "BUG 12 of issue: https://github.com/wazuh/wazuh/issues/14420",
                "ignore_result": true,
                "pattern": "\\d+(\\D*)$",
                "log": "123",
                "end_match": "3",
                "captured_groups": [
                    ""
                ]
            },
            {
                "description": "Last matched character pointed (end_match) should be 't' but it is '3'.",
                "__known_issue": "Matches but if the regex ends with a token with the quantifier '+' or '*', then it does not return the pointer to the last character matched, as it should be. BUG 3 of issue: https://github.com/wazuh/wazuh/issues/14420",
                "ignore_result": true,
                "pattern": "\\d+(\\D*)$",
                "log": "123Test",
                "end_match": "t",
                "captured_groups": [
                    "Test"
                ]
            },
            {
                "description": "Capture group is not correctly obtained. It should be an empty group but it is null.",
                "__known_issue": "BUG 12 of issue: https://github.com/wazuh/wazuh/issues/14420",
                "ignore_result": true,
                "pattern": "\\d+(\\D*)$",
                "log": "Test123",
                "end_match": "3",
                "captured_groups": [
                    ""
                ]
            },
            {
                "description": "Capture group is not correctly obtained. It should be an empty group but it is null.",
                "__known_issue": "BUG 12 of issue: https://github.com/wazuh/wazuh/issues/14420",
                "ignore_result": true,
                "pattern": "(\\d+)\\D*$",
                "log": "123",
                "end_match": "3",
                "captured_groups": [
                    "123"
                ]
            },
            {
                "description": "Capture group is not correctly obtained. It should be an empty group but it is null.",
                "__known_issue": "BUG 12 of issue: https://github.com/wazuh/wazuh/issues/14420",
                "ignore_result": true,
                "pattern": "(\\d+)\\D*$",
                "log": "123Test",
                "end_match": "t",
                "captured_groups": [
                    "123"
                ]
            },
            {
                "description": "Capture group is not correctly obtained. It should be an empty group but it is null.",
                "__known_issue": "BUG 12 of issue: https://github.com/wazuh/wazuh/issues/14420",
                "ignore_result": true,
                "pattern": "(\\d+)\\D*$",
                "log": "Test123",
                "end_match": "3",
                "captured_groups": [
                    "123"
                ]
            },
            {
                "description": "Capture group is not correctly obtained.",
                "__known_issue": "BUG 12 of issue: https://github.com/wazuh/wazuh/issues/14420",
                "ignore_result": true,
                "pattern": "(\\d*)\\w*",
                "log": "123",
                "end_match": "3",
                "captured_groups": [
                    "1"
                ]
            },
            {
                "description": "Capture group is not correctly obtained.",
                "__known_issue": "BUG 12 of issue: https://github.com/wazuh/wazuh/issues/14420",
                "ignore_result": true,
                "pattern": "(\\d*)\\w*",
                "log": "123Test",
                "end_match": "3",
                "captured_groups": [
                    "1"
                ]
            },
            {
                "description": "Regex should match but does not.",
                "__known_issue": "It should match but does not, the states stack is limited to 4 states. BUG 6 of issue: https://github.com/wazuh/wazuh/issues/14420",
                "__known_issue_2": "Only 4 'recoverage' levels are allowed.",
                "ignore_result": true,
                "pattern": "(\\w+1) (\\w+2) (\\w+3) (\\w+4) (\\w+5)",
                "log": "xyz1xyz1 xyz2xyz2 xyz3xyz3 xyz4xyz4 xyz5xyz5",
                "end_match": "5",
                "captured_groups": [
                    "xyz1xyz1",
                    "xyz2xyz2",
                    "xyz3xyz3",
                    "xyz4xyz4",
                    "xyz5xyz5"
                ]
            },
            {
                "description": "Regex should match but does not.",
                "__known_issue": "It should match but does not, the states stack is limited to 4 states. BUG 6 of issue: https://github.com/wazuh/wazuh/issues/14420",
                "__known_issue_2": "Only 4 'recoverage' levels are allowed.",
                "ignore_result": true,
                "pattern": "(\\w+#) (\\w+#) (\\w+#) (\\w+#) (\\w+#) (\\w+#)",
                "log": "a# b# c# d#d# e# f#",
                "end_match": "#",
                "captured_groups": [
                    "a#",
                    "b#",
                    "c#",
                    "d#d#",
                    "e#",
                    "f#"
                ]
            },
            {
                "description": "This case matches.",
                "pattern": "\\w+1 \\w+2 \\w+3 \\w+4 \\w+5",
                "log": "xyz1xyz1 xyz2xyz2 xyz3xyz3 xyz4xyz4 xyz5xyz5",
                "end_match": "5xyz5",
                "captured_groups": []
            },
            {
                "description": "This case does not match.",
                "__known_issue": "It should match but does not, the states stack is limited to 4 states. BUG 6 of issue: https://github.com/wazuh/wazuh/issues/14420",
                "ignore_result": true,
                "pattern": "\\w+1 \\w+2 \\w+3 \\w+4 \\w+5$",
                "log": "xyz1xyz1 xyz2xyz2 xyz3xyz3 xyz4xyz4 xyz5xyz5",
                "end_match": "5",
                "captured_groups": []
            },
            {
                "description": "This case matches.",
                "pattern": "(\\w+1) (\\w+2) (\\w+3) (\\w+4) (\\w+5)",
                "log": "xyz1xyz1 xyz2xyz2 xyz3xyz3 xyz4xyz4 xyz5",
                "end_match": "5",
                "captured_groups": [
                    "xyz1xyz1",
                    "xyz2xyz2",
                    "xyz3xyz3",
                    "xyz4xyz4",
                    "xyz5"
                ]
            },
            {
                "description": "Regex should match but does not.",
                "ignore_result": true,
                "__known_issue": "It should match but does not, the states stack is limited to 4 states. BUG 6 of issue: https://github.com/wazuh/wazuh/issues/14420",
                "pattern": "(\\w+1) (\\w+2) (\\w+3) (\\w+4) (\\w+5) (\\w+6)$",
                "log": "xyz1xyz1 xyz2xyz2 xyz3xyz3 xyz4xyz4 xyz5 xyz6xyz6",
                "end_match": "6",
                "captured_groups": [
                    "xyz1xyz1",
                    "xyz2xyz2",
                    "xyz3xyz3",
                    "xyz4xyz4",
                    "xyz5",
                    "xyz6xyz6"
                ]
            },
            {
                "description": "Regex should match but does not.",
                "ignore_result": true,
                "__known_issue": "It should match but does not, the states stack is limited to 4 states. BUG 6 of issue: https://github.com/wazuh/wazuh/issues/14420",
                "pattern": "\\w+1 \\w+2 \\w+3 \\w+4 \\w+5 \\w+6$",
                "log": "xyz1xyz1 xyz2xyz2 xyz3xyz3 xyz4xyz4 xyz5 xyz6xyz6",
                "end_match": "6",
                "captured_groups": []
            },
            {
                "description": "This case matches.",
                "pattern": "(\\w+1) (\\w+2) (\\w+3) (\\w+4) (\\w+5) (\\w+6)$",
                "log": "xyz1xyz1 xyz2xyz2 xyz3xyz3 xyz4xyz4 xyz5 xyz6",
                "end_match": "6",
                "captured_groups": [
                    "xyz1xyz1",
                    "xyz2xyz2",
                    "xyz3xyz3",
                    "xyz4xyz4",
                    "xyz5",
                    "xyz6"
                ]
            },
            {
                "description": "Regex should match but does not.",
                "ignore_result": true,
                "pattern": "(\\w+1) (\\w+2) (\\w+3) (\\w+4) (\\w+5) (\\w+6)$",
                "__known_issue": "It should match but does not, the states stack is limited to 4 states. BUG 6 of issue: https://github.com/wazuh/wazuh/issues/14420",
                "log": "xyz1xyz1 xyz2xyz2 xyz3xyz3 xyz4xyz4 xyz5xyz5 xyz6",
                "end_match": "6",
                "captured_groups": [
                    "xyz1xyz1",
                    "xyz2xyz2",
                    "xyz3xyz3",
                    "xyz4xyz4",
                    "xyz5xyz5",
                    "xyz6"
                ]
            },
            {
                "description": "Regex should match but does not.",
                "ignore_result": true,
                "pattern": "\\w+1 \\w+2 \\w+3 \\w+4 \\w+5 \\w+6",
                "__known_issue": "It should match but does not, the states stack is limited to 4 states. BUG 6 of issue: https://github.com/wazuh/wazuh/issues/14420",
                "log": "z1 x2 x3 x4 x5x5 x6",
                "end_match": "6",
                "captured_groups": []
            },
            {
                "description": "Regex should match but does not.",
                "ignore_result": true,
                "pattern": "(\\w+1 \\w+2 \\w+3 \\w+4 \\w+5 \\w+6)",
                "__known_issue": "It should match but does not, the states stack is limited to 4 states. BUG 6 of issue: https://github.com/wazuh/wazuh/issues/14420",
                "log": "z1 x2 x3 x4 x5x5 x6",
                "end_match": "6",
                "captured_groups": [
                    "z1 x2 x3 x4 x5x5 x6"
                ]
            },
            {
                "description": "Regex should match but does not.",
                "__known_issue": "It should match but does not, the states stack is limited to 4 states. BUG 6 of issue: https://github.com/wazuh/wazuh/issues/14420",
                "ignore_result": true,
                "pattern": "(\\w+1) (\\w+2) (\\w+3) (\\w+4) (\\w+5) (\\w+6)",
                "log": "z1 x2 x3 x4 x5x5 x6",
                "end_match": "6",
                "captured_groups": [
                    "z1",
                    "x2",
                    "x3",
                    "x4",
                    "x5x5",
                    "x6"
                ]
            },
            {
                "description": "This case matches.",
                "pattern": "\\w+1 \\w+2 \\w+3 \\w+4 \\w+5 \\w+6",
                "log": "z1 x2 x3 x4x4 x5 x6",
                "end_match": "6",
                "captured_groups": []
            },
            {
                "description": "This case matches.",
                "pattern": "(\\w+1 \\w+2 \\w+3 \\w+4 \\w+5 \\w+6)",
                "log": "z1 x2 x3 x4x4 x5 x6",
                "end_match": "6",
                "captured_groups": [
                    "z1 x2 x3 x4x4 x5 x6"
                ]
            },
            {
                "description": "This case matches.",
                "pattern": "(\\w+1) (\\w+2) (\\w+3) (\\w+4) (\\w+5) (\\w+6)",
                "log": "z1 x2 x3 x4x4 x5 x6",
                "end_match": "6",
                "captured_groups": [
                    "z1",
                    "x2",
                    "x3",
                    "x4x4",
                    "x5",
                    "x6"
                ]
            },
            {
                "description": "This case has 3 (non-optional) tokens but it is capturing only 2 characters.",
                "__known_issue": "BUG 13 of issue: https://github.com/wazuh/wazuh/issues/14420",
                "__known_issue_2": "Capture groups could be either '04T15' or '4T15', depending on the (unpredictable) behavior of the greediness.",
                "ignore_result": true,
                "pattern": "(\\d+\\w\\d+)",
                "log": "04T15",
                "end_match": "5",
                "captured_groups": [
                    "04T15"
                ]
            },
            {
                "description": "This case should match but it does not.",
                "__known_issue": "Related BUG 13 of issue: https://github.com/wazuh/wazuh/issues/14420",
                "ignore_result": true,
                "pattern": "(-\\d+\\w\\d+:)",
                "log": "-04T15:",
                "end_match": ":",
                "captured_groups": [
                    "-04T15:"
                ]
            },
            {
                "description": "This case should match but it does not.",
                "__known_issue": "Related BUG 13 of issue: https://github.com/wazuh/wazuh/issues/14420",
                "ignore_result": true,
                "pattern": "-(\\d+\\w\\d+):",
                "log": "-04T15:",
                "end_match": ":",
                "captured_groups": [
                    "04T15"
                ]
            },
            {
                "__known_issue": "Related BUG 13 of issue: https://github.com/wazuh/wazuh/issues/14420",
                "description": "This case should match but it does not.",
                "ignore_result": true,
                "pattern": "-\\d+\\w\\d+:",
                "log": "-04T15:",
                "end_match": ":",
                "captured_groups": []
            },
            {
                "description": "This case matches.",
                "__known_issue": "Related BUG 13 of issue: https://github.com/wazuh/wazuh/issues/14420",
                "__known_issue_2": "Wrong end_match value.",
                "ignore_result": true,
                "pattern": "\\d+\\w\\d+",
                "log": "04T15",
                "end_match": "5",
                "captured_groups": []
            },
            {
                "description": "This case matches.",
                "__known_issue": "Related BUG 13 of issue: https://github.com/wazuh/wazuh/issues/14420",
                "__known_issue_2": "Wrong end_match value.",
                "ignore_result": true,
                "pattern": "(\\d+\\D\\d+)",
                "log": "04T15",
                "end_match": "5",
                "captured_groups": [
                    "04T15"
                ]
            },
            {
                "description": "This case matches.",
                "pattern": "(-\\d+\\D\\d+:)",
                "log": "-04T15:",
                "end_match": ":",
                "captured_groups": [
                    "-04T15:"
                ]
            },
            {
                "description": "This case matches.",
                "pattern": "-(\\d+\\D\\d+):",
                "log": "-04T15:",
                "end_match": ":",
                "captured_groups": [
                    "04T15"
                ]
            },
            {
                "description": "This case matches.",
                "pattern": "-\\d+\\D\\d+:",
                "log": "-04T15:",
                "end_match": ":",
                "captured_groups": []
            },
            {
                "description": "This case matches.",
                "__known_issue": "Wrong end_match value.",
                "ignore_result": true,
                "pattern": "\\d+\\D\\d+",
                "log": "04T15",
                "end_match": "5",
                "captured_groups": []
            },
            {
                "description": "This case matches.",
                "__known_issue": "Related BUG 13 of issue: https://github.com/wazuh/wazuh/issues/14420",
                "__known_issue_2": "Wrong end_match value.",
                "ignore_result": true,
                "pattern": "(\\d+\\D\\d+)",
                "log": "04T15",
                "end_match": "5",
                "captured_groups": [
                    "04T15"
                ]
            },
            {
                "description": "Empty regex should not match but it does.",
                "ignore_result": true,
                "pattern": "",
                "log": "Test",
                "end_match": null,
                "captured_groups": []
            },
            {
                "description": "This case does not match, which is correct.",
                "pattern": "()",
                "log": "Test",
                "end_match": null,
                "captured_groups": [
                    ""
                ]
            },
            {
                "description": "Last matched character pointed (end_match) should be 't' but it is '1'",
                "ignore_result": true,
                "__known_issue": "Matches but if the regex ends with a token with the quantifier '+' or '*', then it does not return the pointer to the last character matched, as it should be. BUG 3 of issue: https://github.com/wazuh/wazuh/issues/14420",
                "pattern": "\\.+",
                "log": "123 Test",
                "end_match": "t",
                "captured_groups": []
            },
            {
                "description": "Last matched character pointed (end_match) should be 't' but it is '1'",
                "__known_issue": "Matches but if the regex ends with a token with the quantifier '+' or '*', then it does not return the pointer to the last character matched, as it should be. BUG 3 of issue: https://github.com/wazuh/wazuh/issues/14420",
                "ignore_result": true,
                "pattern": "\\.+$",
                "log": "123 test",
                "end_match": "t",
                "captured_groups": []
            },
            {
                "description": "Last matched character pointed (end_match) should be 't' but it is '1'",
                "__known_issue": "Matches but if the regex ends with a token with the quantifier '+' or '*', then it does not return the pointer to the last character matched, as it should be. BUG 3 of issue: https://github.com/wazuh/wazuh/issues/14420",
                "ignore_result": true,
                "pattern": "^\\.+",
                "log": "123 test",
                "end_match": "t",
                "captured_groups": []
            },
            {
                "description": "Last matched character pointed (end_match) should be 't' but it is '1'",
                "__known_issue": "Matches but if the regex ends with a token with the quantifier '+' or '*', then it does not return the pointer to the last character matched, as it should be. BUG 3 of issue: https://github.com/wazuh/wazuh/issues/14420",
                "ignore_result": true,
                "pattern": "^\\.+$",
                "log": "123 test",
                "end_match": "t",
                "captured_groups": []
            },
            {
                "description": "Last matched character pointed (end_match) should be 't' but it is '1'",
                "__known_issue": "Matches but if the regex ends with a token with the quantifier '+' or '*', then it does not return the pointer to the last character matched, as it should be. BUG 3 of issue: https://github.com/wazuh/wazuh/issues/14420",
                "ignore_result": true,
                "pattern": "^(\\.+)$",
                "log": "123 test",
                "end_match": "t",
                "captured_groups": [
                    "123 test"
                ]
            },
            {
                "description": "Last matched character pointed (end_match) should be '~' but it is '_'",
                "__known_issue": "Matches but if the regex ends with a token with the quantifier '+' or '*', then it does not return the pointer to the last character matched, as it should be. BUG 3 of issue: https://github.com/wazuh/wazuh/issues/14420",
                "ignore_result": true,
                "pattern": "\\.+",
                "log": "_-@ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789 \r\t!\"#$%&()*+,./:;<=>?[\\]^`{|}~",
                "end_match": "~",
                "captured_groups": []
            },
            {
                "description": "Last matched character pointed (end_match) should be '~' but it is '_'",
                "__known_issue": "Matches but if the regex ends with a token with the quantifier '+' or '*', then it does not return the pointer to the last character matched, as it should be. BUG 3 of issue: https://github.com/wazuh/wazuh/issues/14420",
                "ignore_result": true,
                "pattern": "^\\.+$",
                "log": "_-@ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789 \r\t!\"#$%&()*+,./:;<=>?[\\]^`{|}~",
                "end_match": "~",
                "captured_groups": []
            },
            {
                "description": "Last matched character pointed (end_match) should be '~' but it is '_'",
                "ignore_result": true,
                "pattern": "\\.+$",
                "log": "_-@ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789 \r\t!\"#$%&()*+,./:;<=>?[\\]^`{|}~",
                "end_match": "~",
                "captured_groups": []
            },
            {
                "description": "Last matched character pointed (end_match) should be '~' but it is '_'",
                "ignore_result": true,
                "pattern": "^\\.+",
                "log": "_-@ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789 \r\t!\"#$%&()*+,./:;<=>?[\\]^`{|}~",
                "end_match": "~",
                "captured_groups": []
            },
            {
                "description": "Last matched character pointed (end_match) should be '~' but it is '_'",
                "__known_issue": "Matches but if the regex ends with a token with the quantifier '+' or '*', then it does not return the pointer to the last character matched, as it should be. BUG 3 of issue: https://github.com/wazuh/wazuh/issues/14420",
                "ignore_result": true,
                "pattern": "^(\\.+)$",
                "log": "_-@ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789 \r\t!\"#$%&()*+,./:;<=>?[\\]^`{|}~",
                "end_match": "~",
                "captured_groups": [
                    "_-@ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789 \r\t!\"#$%&()*+,./:;<=>?[\\]^`{|}~"
                ]
            }
        ]
    },
    {
        "description": "[Functionality] Complementary cases.",
        "batch_test": [
            {
                "pattern": "\\(\\)",
                "log": "()",
                "end_match": ")",
                "captured_groups": []
            },
            {
                "pattern": "(\\(\\))",
                "log": "()",
                "end_match": ")",
                "captured_groups": [
                    "()"
                ]
            },
            {
                "pattern": "\\\\",
                "log": "\\",
                "end_match": "\\",
                "captured_groups": []
            },
            {
                "pattern": "(\\\\)",
                "log": "\\",
                "end_match": "\\",
                "captured_groups": [
                    "\\"
                ]
            },
            {
                "pattern": "\\(\\\\\\)",
                "log": "(\\)",
                "end_match": ")",
                "captured_groups": []
            },
            {
                "pattern": "(\\(\\\\\\))",
                "log": "(\\)",
                "end_match": ")",
                "captured_groups": [
                    "(\\)"
                ]
            },
            {
                "pattern": "123 \\W*",
                "log": "123 test",
                "end_match": " test",
                "captured_groups": []
            },
            {
                "pattern": "123 (\\W*)",
                "log": "123 test",
                "end_match": " test",
                "captured_groups": [
                    ""
                ]
            }
        ]
    }
]